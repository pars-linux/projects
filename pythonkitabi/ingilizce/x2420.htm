

  
  <table border="0" cellspacing="0" cellpadding="3" width="100%"><tr><td>
    <div align="center" id="bldcontent">
      <a href="http://www.opendocspublishing.com/"><img src="../images/opendocs.png" width="63" height="76" border="0"></a>
      <br>
      <div class="symbol">Your OpenSource Publisher&#153;</div>
    </div>
    
  </td></tr></table>
  
  <div align="center" class="author">
      	<a href="../products.lxp.html">Products</a>
	&nbsp;|&nbsp;
	<a href="../wheretobuy.lxp.html">Where to buy</a>
	&nbsp;|&nbsp;
	<a href="../bookstore.lxp.html">Retailers</a>
	&nbsp;|&nbsp;
	<a href="../FAQ.lxp.html">FAQ</a>
	&nbsp;|&nbsp;
        <a href="../writeforus.lxp.html">Write for Us.</a>
        &nbsp;|&nbsp;
        <a href="x2420.htm#contact">Contact Us.</a>
  </div>
    <table border="0" cellspacing="3" cellpadding="0" width="100%"><tr><td width="100%">
      <div class="content">
        <table border="0" cellspacing="2" cellpadding="0" width="100%"><tr><td width="100%">
          <div align="center">
<H4 CLASS="AUTHOR"><A NAME="AEN5">Boudewijn Rempt</A>
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
<img src="ODPyQT125.png">
</a>
<br>
ISBN: 0-97003300-4-4
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
Available from bookstores everywhere or you can order it here.
</a>
<p>
You can download the source files for the book <a href="pyqtsrc.tgz">(code / eps) here.</a>
<hr>
</div>

          
          <HTML
><HEAD
><TITLE
>References and ownership</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.72
"><LINK
REL="HOME"
TITLE="GUI Programming with Python: QT Edition"
HREF="book1.htm"><LINK
REL="UP"
TITLE="Python Objects and Qt Objects"
HREF="c2341.htm"><LINK
REL="PREVIOUS"
TITLE="Qt objects, Python objects and shadow objects"
HREF="x2393.htm"><LINK
REL="NEXT"
TITLE="Other C++ objects"
HREF="x2540.htm"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GUI Programming with Python: QT Edition</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A accesskey="P" href="x2393.htm">Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 9. Python Objects and Qt Objects</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A accesskey="N" href="x2540.htm">Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
>References and ownership</A
></H1
><P
>Let's investigate the actual creation and
      deletion of object - both Python and Qt have a role to play here
      - a role they mostly perform without surprising the programmer.
      Still, there are circumstances you should be aware of.</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 9-3. qtrefs1.py &#8212; about Qt reference counting</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#
# qtrefs1.py
#

import sys
from qt import *

class MainWindow(QMainWindow):

    def __init__(self, *args):
        apply(QMainWindow.__init__, (self, ) + args)
        topbutton=QPushButton("A swiftly disappearing button", None)
        topbutton.show()

def main(args):
    app=QApplication(args)
    win=MainWindow()
    win.show()
    app.connect(app, SIGNAL("lastWindowClosed()")
                , app
                , SLOT("quit()")
                )
    app.exec_loop()

if __name__=="__main__":
        main(sys.argv)
      </PRE
></DIV
><P
>Here, we create a window, and in the
      constructor (the <TT
CLASS="FUNCTION"
>__init__</TT
> method), we
      create a QPushButton. That button really should appear as a
      second toplevel window - but it doesn't. The reason is that the
      only reference to the object is the variable
      <TT
CLASS="VARNAME"
>topbutton</TT
>, and that variable goes out of
      scope once the constructor method finishes. The reference ceases
      to exist, and so the object is deleted.</P
><P
>If we want to keep the button alive, we
      should keep the reference alive. The easiest way to do that is
      to associate the button more closely with the containing window
      object. It is customary to refer to the containing object with
      the variable <TT
CLASS="VARNAME"
>self</TT
>. Python passes a reference
      to an object as the first argument to any instance method. This
      reference is usually named self.</P
><P
>So, if we adapt the preceding example as follows, we keep
      the object:</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 9-4. qtrefs2.py - keeping a Qt widget alive</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#
# qtrefs2.py
#

import sys
from qt import *

class MainWindow(QMainWindow):

    def __init__(self, *args):
        apply(QMainWindow.__init__, (self, ) + args)
        self.topbutton=QPushButton("A nice and steady button",
                                   None)
        self.topbutton.show()

def main(args):
    app=QApplication(args)
    win=MainWindow()
    win.show()
    app.connect(app, SIGNAL("lastWindowClosed()")
                , app
                , SLOT("quit()")
                )
    app.exec_loop()

if __name__=="__main__":
        main(sys.argv)
        </PRE
></DIV
><P
>Does this mean that you always need to keep
      a reference to all Qt objects yourself? This would make creating
      complex applications quite a drag! Fortunately, sip is more
      clever than it seems. <TT
CLASS="CLASSNAME"
>QObject</TT
> derived
      objects stand in a owner-ownee (or parent-child) relation to
      each other. Sip knows this, and creates references to child
      objects on the fly, and decreases those references if the
      parents are deleted. (The Qt library does something similar if
      you program in C++. This gives a kind of Java-like flavor to C++
      which is not appreciated by everyone).</P
><P
>To keep a widget's child alive, enter the
      parent object in the <TT
CLASS="VARNAME"
>parent</TT
> argument of the
      child constructor, in this case, this is the second argument to
      the <TT
CLASS="CLASSNAME"
>QPushButton</TT
> constructor:</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 9-5. qtrefs3.py - Qt parents and children</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#
# qtrefs3.py
#

import sys
from qt import *

class MainWindow(QMainWindow):

    def __init__(self, *args):
        apply(QMainWindow.__init__, (self, ) + args)
        parentedButton=QPushButton("A nice and steady button "
                                  + "that knows its place",
                                  self)
        parentedButton.resize(parentedButton.sizeHint())

def main(args):
    app=QApplication(args)
    win=MainWindow()
    win.show()
    app.connect(app, SIGNAL("lastWindowClosed()"),
                app,
                SLOT("quit()"))
    app.exec_loop()

if __name__=="__main__":
        main(sys.argv)
        </PRE
></DIV
><P
>Note however these two important
      side-effects: The first is that this button, now that it is
      owned by the main window, appears <SPAN
><I
CLASS="EMPHASIS"
>inside</I
></SPAN
>
      the main window. The second is that you no longer need to
      explicitly call the function <TT
CLASS="FUNCTION"
>show()</TT
> on the
      button.</P
><P
>As another side-effect of explicitly
      parenting objects, you need to be aware of who owns an object
      before you can be sure that it will be deleted: your Python
      application or another Qt object.</P
><P
>The trick is to determine who exactly owns
      the widget in question. Everything that is derived from
      <TT
CLASS="CLASSNAME"
>QObject</TT
> has the function
      <TT
CLASS="FUNCTION"
>parent()</TT
>, which can be used to determine
      the owner of a widget. You can use the function
      <TT
CLASS="FUNCTION"
>removeChild</TT
> to remove the widget itself.
      Using <TT
CLASS="FUNCTION"
>parent()</TT
> is often easier than
      remembering who exactly owned the widget you want to get rid
      of.</P
><PRE
CLASS="PROGRAMLISTING"
>self.parent().removeChild(self)
    </PRE
><P
>If you execute this incantation, the poor widget will be
      orphaned, and a Python <TT
CLASS="FUNCTION"
>del</TT
> statement on the
      Python reference will definitively remove the child.</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 9-6. Eradicating a widget</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#
# qtrefs4.py - removing a widget
#

import sys
from qt import *

class MainWindow(QMainWindow):

    def __init__(self, *args):
        apply(QMainWindow.__init__, (self, ) + args)
        self.parentedButton=QPushButton("A nice and steady button "
                                   + "that knows its place",
                                   self)
        self.parentedButton.resize(self.parentedButton.sizeHint())
        self.connect(self.parentedButton,
                     SIGNAL("clicked()"),
                     self.removeButton)

    def removeButton(self):
        self.removeChild(self.parentedButton)
        del self.parentedButton


def main(args):
    app=QApplication(args)
    win=MainWindow()
    win.show()
    app.connect(app, SIGNAL("lastWindowClosed()"),
                app, SLOT("quit()"))
    app.exec_loop()

if __name__=="__main__":
        main(sys.argv)
      </PRE
></DIV
><P
>Pressing the button will remove it, first by removing
      the ownership relation between <TT
CLASS="VARNAME"
>win</TT
> and
      <TT
CLASS="VARNAME"
>self.parentedButton</TT
> and then removing the
      Python reference to the object.</P
><P
>It is possible to retrieve the children of a certain QObject
      object by calling <TT
CLASS="FUNCTION"
>children</TT
> on QObject. Sip
      is clever enough to return the Python wrapper object associated with that
      instance (rather than the actual C++ object instance).</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 9-7. children.py - getting the children from a single
        parent</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#
# children.py
#

import sys
from qt import *

def printChildren(obj, indent):
    children=obj.children()
    if children==None:
        return
    for child in children:
        print indent, child.name(), child.__class__
        printChildren(child, indent + "  ")

class PyPushButton(QPushButton): pass

class MainWindow(QMainWindow):

    def __init__(self, *args):
        apply(QMainWindow.__init__, (self, ) + args)
        mainwidget=QWidget(self, "mainwidget")
        layout=QVBoxLayout(mainwidget, 2, 2, "layout")
        button1=QPushButton("button1", mainwidget, "button1")
        button2=PyPushButton("button2", mainwidget, "button2")
        layout.addWidget(button1)
        layout.addWidget(button2)

        self.setCentralWidget(mainwidget)
        printChildren(self, "  ")

def main(args):
    app=QApplication(args)
    win=MainWindow()
    win.show()
    app.connect(app, SIGNAL("lastWindowClosed()")
                , app
                , SLOT("quit()")
                )
    app.exec_loop()

if __name__=="__main__":
        main(sys.argv)
        </PRE
></DIV
><P
>Running children.py will give the following output:</P
><PRE
CLASS="SCREEN"
>boudewijn@maldar:~/doc/opendoc &#62; python children.py
   hide-dock qt.QObject
   mainwidget qt.QWidget
     layout qt.QVBoxLayout
     button1 qt.QPushButton
     button2 __main__.PyPushButton
   unnamed qt.QObject
     unnamed qt.QObject
     unnamed qt.QObject
       unnamed qt.QObject
       unnamed qt.QObject
     unnamed qt.QObject</PRE
><P
>What you cannot see here is the parallel structure of
      <TT
CLASS="CLASSNAME"
>QLayoutItems</TT
> that proxy for the widgets.
      For that you need to use the
      <TT
CLASS="CLASSNAME"
>QLayoutIterator</TT
> that is provided by the
      <TT
CLASS="FUNCTION"
>iterator()</TT
> method of
      <TT
CLASS="CLASSNAME"
>QListViewItem</TT
>. Here,
      <TT
CLASS="FUNCTION"
>next()</TT
>, both returns the next item, and
      moves the iterator onwards.</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 9-8. Iterating over children</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#
# children.py
#

import sys
from qt import *

def printChildren(obj, indent):
    iter = obj.iterator()
    while iter.current():
        print "current:", iter.current()
        print "next:", iter.next()

class PyPushButton(QPushButton): pass

class MainWindow(QMainWindow):

    def __init__(self, *args):
        apply(QMainWindow.__init__, (self, ) + args)
        mainwidget=QWidget(self, "mainwidget")
        layout=QVBoxLayout(mainwidget, 2, 2, "layout")
        button1=QPushButton("button1", mainwidget, "button1")
        button2=PyPushButton("button2", mainwidget, "button2")
        button3=PyPushButton("button3", mainwidget, "button3")
        layout.addWidget(button1)
        layout.addWidget(button2)
        layout.addWidget(button3)
        
        self.setCentralWidget(mainwidget)
        printChildren(layout, "  ")
        
def main(args):
    app=QApplication(args)
    win=MainWindow()
    win.show()
    app.connect(app, SIGNAL("lastWindowClosed()")
                , app
                , SLOT("quit()")
                )
    app.exec_loop()
  
if __name__=="__main__":
        main(sys.argv)
      </PRE
></DIV
><PRE
CLASS="SCREEN"
>boud@calcifer:~/doc/pyqt/src/qt2/ch3 &#62; python layoutchildren.py
current: &#60;qt.QLayoutItem instance at 0x82ba8b4&#62; 
next: &#60;qt.QLayoutItem instance at 0x82ba9dc&#62;
current: &#60;qt.QLayoutItem instance at 0x82ba9dc&#62; 
next: &#60;qt.QLayoutItem instance at 0x82baa8c&#62;
current: &#60;qt.QLayoutItem instance at 0x82baa8c&#62; 
next: None
    </PRE
><P
>Finally, let's test the ownership rules of
      Qt and Python objects using the interactive Python interpreter.
      In the following example, we create an object
      <TT
CLASS="VARNAME"
>self.o</TT
>, owned by PyQt, and then a child
      object is created, not owned by the instance of class
      <TT
CLASS="CLASSNAME"
>A</TT
>, but as a Qt child of object
      <TT
CLASS="VARNAME"
>self.o</TT
>. Thus, PyQt owns <TT
CLASS="VARNAME"
>a</TT
>
      and <TT
CLASS="VARNAME"
>self.o</TT
>, and Qt owns
      <TT
CLASS="VARNAME"
>child</TT
>, and <TT
CLASS="VARNAME"
>child</TT
> doesn't
      get deleted, even when the Python reference goes out of
      scope.</P
><PRE
CLASS="SCREEN"
>&#62;&#62;&#62; from qt import QObject
&#62;&#62;&#62; class A:
...     def __init__(self):
...             self.o=QObject()
...             child = QObject(self.o)
... 
&#62;&#62;&#62; a=A()
&#62;&#62;&#62; print a
&#60;__main__.A instance at 0x821cdac&#62;
&#62;&#62;&#62; print a.o
&#60;qt.QObject instance at 0x821ce04&#62;
&#62;&#62;&#62; print a.o.children()
[&#60;qt.QObject instance at 0x821cf54&#62;]
&#62;&#62;&#62; 
    </PRE
><P
>On the other hand, the following won't
      work, because as soon as the execution flow leaves the
      constructor, <TT
CLASS="VARNAME"
>o</TT
> is garbage collected, and
      <TT
CLASS="VARNAME"
>child</TT
>, is then garbage-collected, too, since
      it isn't owned by a Qt object, and Python doesn't have a
      reference to it anymore, either.</P
><PRE
CLASS="SCREEN"
> &#62;&#62;&#62; class B:
...        def ___init__(self):
...             o=QObject()
...             child = QObject(o)
... 
&#62;&#62;&#62; b=B()
&#62;&#62;&#62; b.o
Traceback (most recent call last):
  File "&#60;stdin&#62;", line 1, in ?
AttributeError: o
    </PRE
><P
>On the other hand, it isn't necessary to
      keep a Python reference to all created objects: as long as the
      ultimate parent object is owned by PyQt, everything will go
      well:</P
><PRE
CLASS="SCREEN"
>&#62;&#62;&#62; class C:
...        def __init__(self):
...             self.o = QObject()
...             self.child = QObject(self.o)
... 
&#62;&#62;&#62; c = C()
&#62;&#62;&#62; c.o
&#60;qt.QObject instance at 0x8263f54&#62;
&#62;&#62;&#62; c.o.children()
[&#60;qt.QObject instance at 0x821d334&#62;]
&#62;&#62;&#62; c.child
&#60;qt.QObject instance at 0x821d334&#62;
&#62;&#62;&#62; </PRE
><P
>As you see, it isn't necessary to keep a reference to
      <TT
CLASS="VARNAME"
>child</TT
>,- because PyQt is the owner of the
      first object (because it has no Qt parent but a reference to a
      Python object) but Qt is the owner of the second widget (because
      it <SPAN
><I
CLASS="EMPHASIS"
>does</I
></SPAN
> have a parent) and so the C++
      instance (qt.QObject instance at 0x821d334) is not deleted when
      the corresponding Python object goes out of scope.</P
><P
>What if your Python class were a subclass of
      <TT
CLASS="CLASSNAME"
>QObject</TT
>?:</P
><PRE
CLASS="SCREEN"
>&#62;&#62;&#62; class D(QObject):
...        def __init__(self):
...             QObject.__init__(self)
...             o=QObject(self)
...             child = QObject(o)
... 
&#62;&#62;&#62; d=D()
&#62;&#62;&#62; d.children()
[&#60;qt.QObject instance at 0x821d614&#62;]
&#62;&#62;&#62; d.children()[0].children()
[&#60;qt.QObject instance at 0x821d7c4&#62;]
&#62;&#62;&#62; 
    </PRE
><P
>As you can see, <TT
CLASS="VARNAME"
>o</TT
> doesn't get deleted,
      nor <TT
CLASS="VARNAME"
>child</TT
> - both are owned by Qt and will be
      deleted as soon as object <TT
CLASS="VARNAME"
>d</TT
> is deleted. You
      can still reach these objects by using the
      <TT
CLASS="FUNCTION"
>children()</TT
> function
      <TT
CLASS="CLASSNAME"
>QObject</TT
> provides.</P
><P
>This layer between Python and Qt is implemented in the
      <SPAN
><I
CLASS="EMPHASIS"
>sip</I
></SPAN
> library &#8212; sip not only generates
      the wrapper code, but is a library in its own right, containing
      functionality for the passing of object references between C++
      and Python.</P
><P
>Sip is also responsible for the reference counting
      mechanisms. In most cases, Sip is clever enough to closely
      simulate Python behavior for C++ Qt objects. As you saw in the previous example,
      contrary to what happens in C++, when you remove the last
      reference to a C++ object, it will be automatically deleted by
      Sip.</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A accesskey="P" href="x2393.htm">Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="H" href="book1.htm">Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A accesskey="N" href="x2540.htm">Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Qt objects, Python objects and shadow objects</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="U" href="c2341.htm">Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Other C++ objects</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
      </td>
      </tr>
      </table>
      </td>
    </tr>
  </table>
  
    
