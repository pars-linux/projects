

  
  <table border="0" cellspacing="0" cellpadding="3" width="100%"><tr><td>
    <div align="center" id="bldcontent">
      <a href="http://www.opendocspublishing.com/"><img src="../images/opendocs.png" width="63" height="76" border="0"></a>
      <br>
      <div class="symbol">Your OpenSource Publisher&#153;</div>
    </div>
    
  </td></tr></table>
  
  <div align="center" class="author">
      	<a href="../products.lxp.html">Products</a>
	&nbsp;|&nbsp;
	<a href="../wheretobuy.lxp.html">Where to buy</a>
	&nbsp;|&nbsp;
	<a href="../bookstore.lxp.html">Retailers</a>
	&nbsp;|&nbsp;
	<a href="../FAQ.lxp.html">FAQ</a>
	&nbsp;|&nbsp;
        <a href="../writeforus.lxp.html">Write for Us.</a>
        &nbsp;|&nbsp;
        <a href="x7161.htm#contact">Contact Us.</a>
  </div>
    <table border="0" cellspacing="3" cellpadding="0" width="100%"><tr><td width="100%">
      <div class="content">
        <table border="0" cellspacing="2" cellpadding="0" width="100%"><tr><td width="100%">
          <div align="center">
<H4 CLASS="AUTHOR"><A NAME="AEN5">Boudewijn Rempt</A>
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
<img src="ODPyQT125.png">
</a>
<br>
ISBN: 0-97003300-4-4
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
Available from bookstores everywhere or you can order it here.
</a>
<p>
You can download the source files for the book <a href="pyqtsrc.tgz">(code / eps) here.</a>
<hr>
</div>

          
          <HTML
><HEAD
><TITLE
>Integrating macros with a GUI</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.72
"><LINK
REL="HOME"
TITLE="GUI Programming with Python: QT Edition"
HREF="book1.htm"><LINK
REL="UP"
TITLE="A Macro Language for Kalam"
HREF="c6996.htm"><LINK
REL="PREVIOUS"
TITLE="A Macro Language for Kalam"
HREF="c6996.htm"><LINK
REL="NEXT"
TITLE="Creating a macro API from an application"
HREF="x7295.htm"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GUI Programming with Python: QT Edition</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A accesskey="P" href="c6996.htm">Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 20. A Macro Language for <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A accesskey="N" href="x7295.htm">Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
>Integrating macros with a GUI</A
></H1
><P
>Before we can start defining what we allow
      our users to do to <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
>, we need to
      build the core macro execution functionality. The first step is
      to make sure users can execute the contents of a
      document.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>Executing the contents of a document</A
></H2
><P
>Unless you have skipped all previous
        occasions of creating and adding an action to the menubar and
        the toolbar, you will know by now how to do so. I have
        supplied the slot code that executes the contents of the
        currently active document. You will find the complete code in
        the <TT
CLASS="FILENAME"
>kalamapp.py</TT
> file that belongs to this
        chapter.</P
><PRE
CLASS="PROGRAMLISTING"
># kalamapp.py
...
class KalamApp(QMainWindow):
...
    # Macro slots
...
    def slotMacroExecuteDocument(self):
        if self.docManager.activeDocument() == None:
            QMessageBox.critical(self,
                                 "Kalam",
                                 "No document to execute as a macro ")
            return

        try:
            bytecode = compile(str(self.docManager.activeDocument().text()),
                               "&#60;string&#62;",
                               "exec")
        except Exception, e:
            QMessageBox.critical(self,
                                 "Kalam",
                                 "Could not compile " +
                                 self.docManager.activeDocument().title() +
                                 "\n" + str(e))
        try:
            exec bytecode # Note: we don't yet have a separate namespace
                          # for macro execution
        except Exception, e:
            QMessageBox.critical(self,
                                 "Kalam",
                                 "Error executing " +
                                 self.docManager.activeDocument().title() +
                                 "\n" + str(e))
...
      </PRE
><P
>We are being a bit careful here, and
        thus compile the code first to check for syntax errors. These,
        along with execution errors, will be shown in a dialog box.
        Note that anything you print from here will go to standard
        output&#8212;that is, a black hole if you run
        <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
> by activating an icon, or the
        terminal window if you run <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
>
        from the shell prompt. It would be a logical step to redirect
        any output to a fresh <TT
CLASS="CLASSNAME"
>Kalam</TT
> document
        (this is what <SPAN
CLASS="APPLICATION"
>Emacs</SPAN
> does). It is
        quite easy to achieve. You can reassign the standard and error
        output channels to any object you want, as long as it has a
        <TT
CLASS="FUNCTION"
>write()</TT
> function that accepts a string.
        We might want to add a <TT
CLASS="FUNCTION"
>write()</TT
> function
        to <TT
CLASS="CLASSNAME"
>KalamDoc</TT
>.</P
><P
>The implementation of
        <TT
CLASS="FUNCTION"
>write()</TT
> in
        <TT
CLASS="CLASSNAME"
>KalamDoc</TT
> is very simple:</P
><PRE
CLASS="PROGRAMLISTING"
># kalamdoc.py - fragment
...
    def write(self, text, view = None):
        self.text().append(text)
        self.emit(PYSIGNAL("sigDocTextChanged"),
                  (self._text, view))
      </PRE
><P
>Having done that, redirecting all output
        is easy:</P
><PRE
CLASS="PROGRAMLISTING"
>        ...
    def slotMacroExecuteDocument(self):
        ...
            import sys
            document = self.docManager.createDocument(KalamDoc, KalamView)
            document.setTitle("Output of " + title)
            oldstdout = sys.stdout
            oldstderr = sys.stderr

            sys.stdout = document
            sys.stderr = document

            exec bytecode # Note: we don't yet have a separate namespace
                          # for macro execution

            sys.stdout = oldstdout
            sys.stderr = oldstderr
        ...
      </PRE
><P
>It is necessary to save the "real"
        standard output and standard error channels in order to be
        able to restore them when we are done printing to the output
        document. Otherwise all output, from anywhere inside Kalam,
        would go forever to that document, with nasty consequences if
        the user were to remove the document.</P
><P
>Until we create a namespace specially
        for executing macros, everything runs locally to the function
        that executes the macro. That is, you can use
        <TT
CLASS="VARNAME"
>self</TT
> to refer to the current instance of
        <TT
CLASS="CLASSNAME"
>KalamApp</TT
>.</P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>Executing a bit of code from a
            document.</P
></DIV
></P
></DIV
><P
>Of course, littering the
        <TT
CLASS="CLASSNAME"
>KalamApp</TT
> with macro execution code
        isn't the best of ideas. This leads us to the creation of a
        macro manager class, <TT
CLASS="CLASSNAME"
>MacroManager</TT
>,
        which keeps a dictionary of compiled code objects that can be
        executed at will. I won't show the unit tests here: it is
        available with the full source code.</P
><PRE
CLASS="PROGRAMLISTING"
>"""
macromanager.py - manager class for macro administration and execution

copyright: (C) 2001, Boudewijn Rempt
email:     boud@rempt.xs4all.nl
"""

from qt import *
import sys

class MacroError(Exception):pass

class NoSuchMacroError(MacroError):

    def __init__(self, macro):
        ERR = "Macro %s is not installed"
        self.errorMessage = ERR % (macro)

    def __repr__(self):
        return self.errorMessage

    def __str__(self):
        return self.errorMessage


class CompilationError(MacroError):

    def __init__(self, macro, error):
        ERR = "Macro %s could not be compiled. Reason: %s"
        self.errorMessage = ERR % (macro, str(error))
        self.compilationError = error

    def __repr__(self):
        return self.errorMessage

    def __str__(self):
        return self.errorMessage

class ExecutionError(MacroError):

    def __init__(self, error):
        ERR = "Macro could not be executed. Reason: %s"
        self.errorMessage = ERR % (str(error))
        self.executionError = error

    def __repr__(self):
        return self.errorMessage

    def __str__(self):
        return self.errorMessage
      </PRE
><P
>First, a couple of exceptions are
        defined. We want to separate the GUI handling of problems with
        the macro from the actual execution, so that whenever
        something goes wrong, an exception is thrown.</P
><PRE
CLASS="PROGRAMLISTING"
>class MacroAction(QAction):

    def __init__(self, code, *args):
        apply(QAction.__init__,(self,) + args)
        self.code = code
        self.bytecode = self.__compile(code)
        self.locations=[]
        self.connect(self,
                     SIGNAL("activated()"),
                     self.activated)

    def activated(self):
        self.emit(PYSIGNAL("activated"),(self,))

    def addTo(self, widget):
        apply(QAction.addTo,(self, widget))
        self.locations.append(widget)

    def removeFrom(self, widget):
        QAction.removeFrom(self, widget)
        del self.locations[widget]

    def remove(self):
        for widget in self.locations:
            self.removeFrom(widget)

    def __compile(self, code):
        try:
            bytecode = compile(code,
                               "&#60;string&#62;",
                               "exec")
            return bytecode
        except Exception, e:
            raise CompilationError(macroName, e)

    def execute(self, out, err, globals, locals):
        try:
            oldstdout = sys.stdout
            oldstderr = sys.stderr
            
            sys.stdout = out
            sys.stderr = err
            exec self.bytecode in globals
            sys.stdout = oldstdout
            sys.stderr = oldstderr
        except Exception, e:
            print e
            print sys.exc_info
            sys.stdout = oldstdout
            sys.stderr = oldstderr
            raise ExecutionError(e)
      </PRE
><P
>By encapsulating each macro in a
        <TT
CLASS="CLASSNAME"
>QAction</TT
>, it will become very easy to
        assign shortcut keys, menu items and toolbar buttons to a
        macro.</P
><P
>The <TT
CLASS="CLASSNAME"
>MacroAction</TT
>
        class also takes care of compilation and execution. The
        environment, consisting of the <TT
CLASS="VARNAME"
>globals</TT
> and
        <TT
CLASS="VARNAME"
>locals</TT
> dictionaries, is passed in the
        <TT
CLASS="FUNCTION"
>execute()</TT
> function. We also pass two
        objects that replace the standard output and standard error
        objects. These can be Kalam documents, for instance. Note how
        we carefully restore the standard output and standard error
        channels. The output of the print statement in the exception
        clause will go to the redefined channel (in this instance, the
        kalam document).</P
><PRE
CLASS="PROGRAMLISTING"
>class MacroManager(QObject):

    def __init__(self, parent = None, g = None, l = None, *args):
        """ Creates an instance of the MacroManager.
        Arguments:
        g = dictionary that will be used for the global namespace
        l = dictionary that will be used for the local namespace
        """
        apply(QObject.__init__,(self, parent,) + args)

        self.macroObjects = {}

        if g == None:
            self.globals = globals()
        else:
            self.globals = g

        if l == None:
            self.locals = locals()
        else:
            self.locals = l
      </PRE
><P
>All macros should be executed in the
        same environment, which is why the macromanager can be
        constructed with a <TT
CLASS="VARNAME"
>globals</TT
> and a
        <TT
CLASS="VARNAME"
>locals</TT
> environment. This environment will
        be used later to create a special API for the macro execution
        environment, and it will include access to the window (i.e.
        the <TT
CLASS="CLASSNAME"
>KalamApp</TT
> object) and to the
        document objects (via the <TT
CLASS="CLASSNAME"
>DocManager</TT
>
        object).</P
><PRE
CLASS="PROGRAMLISTING"
>    def deleteMacro(self, macroName):
        del self.macroObjects[macroName]

    def addMacro(self, macroName, macroString):
        action = MacroAction(macroString, self.parent())
        self.macroObjects[macroName] = action
        self.connect(action,
                     PYSIGNAL("activated"),
                     self.executeAction)
        return action

    def executeAction(self, action):
        action.execute(sys.stdout,
                       sys.stderr,
                       self.globals,
                       self.locals)
      </PRE
><P
>The rest of the
        <TT
CLASS="CLASSNAME"
>MacroManager</TT
> class is simple, including
        methods to delete and add macros, and to execute a named
        macro. Note how the <TT
CLASS="VARNAME"
>activated</TT
> signal of the
        <TT
CLASS="CLASSNAME"
>MacroAction</TT
> is connected to the
        <TT
CLASS="FUNCTION"
>executeAction</TT
> slot. This slot then calls
        <TT
CLASS="FUNCTION"
>execute()</TT
> on the macro action with
        standard output and standard error as default output channels.
        A macro can, of course, create a new document and divert
        output to that document.</P
><P
>The <TT
CLASS="CLASSNAME"
>MacroManager</TT
>
        is instantiated as part of the startup process of the main
        application:</P
><PRE
CLASS="PROGRAMLISTING"
>    # kalamapp.py
    def initMacroManager(self):
        g=globals()
        self.macroManager = MacroManager(self, g)
      </PRE
><P
>Initializing the macromanager will also
        entail deciding upon a good API for the macro extensions. This
        will be covered in a later section.</P
><P
>Adapting the
        <TT
CLASS="FUNCTION"
>slotMacroExecuteDocument()</TT
> slot function
        to use the <TT
CLASS="CLASSNAME"
>MacroManager</TT
> is quite
        straightforward:</P
><PRE
CLASS="PROGRAMLISTING"
>    # kalamapp.py
    def slotMacroExecuteDocument(self):
        if self.docManager.activeDocument() == None:
            QMessageBox.critical(self,
                                 "Kalam",
                                 "No document to execute as a macro ")
            return

        title = self.docManager.activeDocument().title()
        
        try:
            macroText = str(self.docManager.activeDocument().text())
            self.macroManager.addMacro(title, macroText)
        except CompilationError, e:
            QMessageBox.critical(self,
                                 "Kalam",
                                 "Could not compile " +
                                 self.docManager.activeDocument().title() +
                                 "\n" + str(e))
            return
        
        try:
            doc, view = self.docManager.createDocument(KalamDoc, KalamView)
            doc.setTitle("Output of " + title)
            self.macroManager.executeMacro(title, doc, doc)
        except NoSuchMacroError, e:
            QMessageBox.critical(self,
                                 "Kalam",
                                 "Error: could not find execution code.")
        except ExecutionError, e:
            QMessageBox.critical(self,
                                 "Kalam",
                                 "Error executing " + title +
                                 "\n" + str(e))            
        except Exception, e:
            QMessageBox.critical(self,
                                 "Kalam",
                                 "Unpleasant error %s when trying to run %s." \
                                 % (str(e), title))
      </PRE
><P
>Note the careful handling of exceptions.
        You don't want your application to crash or become unstable
        because of a silly error in a macro.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>startup macros</A
></H2
><P
>Executing the contents of a document is
        very powerful in itself&#8212;especially since we have access
        to the complete <TT
CLASS="CLASSNAME"
>KalamApp</TT
> object, from
        which we can reach the most outlying reaches of
        <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
>.</P
><P
>It would be very unpleasant for a user
        to have to load his macros as a document every time he wants
        to execute a macro. Ideally, a user should be able to define a
        set of macros that run at start-up, and be able to
        add macros to menu options and the keyboard.</P
><P
>Solving the first problem takes care of
        many other problems in one go. Users who are capable of
        creating macros are probably able to create a startup macro
        script that loads all their favorite macros.</P
><P
>We define two keys in the configuration
        file, <TT
CLASS="VARNAME"
>macrodir</TT
> and
        <TT
CLASS="VARNAME"
>startupscript</TT
>. These are the name and
        location of the Python script that is executed when
        <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
> is started. We start a user
        macro after all standard initialization is complete:
        </P
><PRE
CLASS="PROGRAMLISTING"
># kalamapp.py - fragment
...
class KalamApp(QMainWindow):
    def __init__(self, *args):
        apply(QMainWindow.__init__,(self, ) + args)
        ...
        # Run the startup macro script
        self.runStartup()

    ...

    def runStartup(self):
        """Run a Python script using the macro manager. Which script is
        run is defined in the configuration variables macrodir and startup.

        All output, and eventual failures are shown on the command-line.
        """
        try:
            startupScript = os.path.join(kalamconfig.get("macrodir"),
                                         kalamconfig.get("startupscript"))
            startup = open(startupScript).read()
            self.macroManager.addMacro("startup", startup)
            self.macroManager.executeMacro("startup")
        except Exception, e:
            print "Could not execute startup macro", e
        </PRE
><P
>A sample startup script might start
      <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
> with an empty document:</P
><PRE
CLASS="PROGRAMLISTING"
># startup.py - startup script for Kalam
print "Kalam startup macro file"
self.docManager.createDocument(KalamDoc, KalamView)
      </PRE
><P
>It is already possible to do anything
        you want using these macro extensions, but life can be made
        easier by providing shortcut functions: a special macro API.
        We will create one in the next section. However, a serious
        macro writer would have to buy a copy of this book in order to
        be able to use all functionality, because hiding the
        underlying GUI toolkit would remove far too much power from
        his hands. </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A accesskey="P" href="c6996.htm">Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="H" href="book1.htm">Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A accesskey="N" href="x7295.htm">Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>A Macro Language for <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="U" href="c6996.htm">Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Creating a macro API from an application</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
      </td>
      </tr>
      </table>
      </td>
    </tr>
  </table>
  
    
