

  
  <table border="0" cellspacing="0" cellpadding="3" width="100%"><tr><td>
    <div align="center" id="bldcontent">
      <a href="http://www.opendocspublishing.com/"><img src="../images/opendocs.png" width="63" height="76" border="0"></a>
      <br>
      <div class="symbol">Your OpenSource Publisher&#153;</div>
    </div>
    
  </td></tr></table>
  
  <div align="center" class="author">
      	<a href="../products.lxp.html">Products</a>
	&nbsp;|&nbsp;
	<a href="../wheretobuy.lxp.html">Where to buy</a>
	&nbsp;|&nbsp;
	<a href="../bookstore.lxp.html">Retailers</a>
	&nbsp;|&nbsp;
	<a href="../FAQ.lxp.html">FAQ</a>
	&nbsp;|&nbsp;
        <a href="../writeforus.lxp.html">Write for Us.</a>
        &nbsp;|&nbsp;
        <a href="c7391.htm#contact">Contact Us.</a>
  </div>
    <table border="0" cellspacing="3" cellpadding="0" width="100%"><tr><td width="100%">
      <div class="content">
        <table border="0" cellspacing="2" cellpadding="0" width="100%"><tr><td width="100%">
          <div align="center">
<H4 CLASS="AUTHOR"><A NAME="AEN5">Boudewijn Rempt</A>
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
<img src="ODPyQT125.png">
</a>
<br>
ISBN: 0-97003300-4-4
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
Available from bookstores everywhere or you can order it here.
</a>
<p>
You can download the source files for the book <a href="pyqtsrc.tgz">(code / eps) here.</a>
<hr>
</div>

          
          <HTML
><HEAD
><TITLE
>Drawing on Painters and Canvases</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.72
"><LINK
REL="HOME"
TITLE="GUI Programming with Python: QT Edition"
HREF="book1.htm"><LINK
REL="UP"
TITLE="Creating real applications with PyQt"
HREF="p4627.htm"><LINK
REL="PREVIOUS"
TITLE="Conclusion"
HREF="x7388.htm"><LINK
REL="NEXT"
TITLE="QCanvas"
HREF="x7601.htm"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GUI Programming with Python: QT Edition</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A accesskey="P" href="x7388.htm">Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A accesskey="N" href="x7601.htm">Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
>Chapter 21. Drawing on Painters and Canvases</A
></H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A href="c7391.htm#AEN7412">Working with painters and paint devices</A
></DT
><DT
><A href="x7601.htm">QCanvas</A
></DT
><DT
><A href="x7875.htm">Conclusion</A
></DT
></DL
></DIV
><P
>Constructing windows out of predefined
    widgets is all very nice, but the real exciting stuff occurs when
    you have to leave the beaten track and push the pixels around
    yourself. This happens when you want to create diagram editors,
    drawing applications, games (especially games!), complex page
    layout engines (like an html renderer), charts, and plots.</P
><P
>Python and PyQt form a good basis for this
    kind of work, because Qt already has two very powerful and
    optimized drawing engines: the <TT
CLASS="CLASSNAME"
>QCanvas</TT
>
    class and the <TT
CLASS="CLASSNAME"
>QPainter</TT
>.
    <TT
CLASS="CLASSNAME"
>QCanvas</TT
> is extremely useful if your drawing
    can be composed from separate elements, and if you want to be able
    to track events that occur on those individual elements, such as
    mouse clicks.</P
><P
><TT
CLASS="CLASSNAME"
>QPainter</TT
> offers finer
    control of what you put on screen, at the cost of losing control
    over the individual elements that make up the drawing.
    <TT
CLASS="CLASSNAME"
>QPainter</TT
> is more suited to drawing charts,
    bit-mapped drawings and plots. If you want real plotting power,
    you should investigate PyQwt, which is introduced in 
    <A href="a8743.htm">Appendix B</A
></P
><P
>Both <TT
CLASS="CLASSNAME"
>QCanvas</TT
> and
    <TT
CLASS="CLASSNAME"
>QPainter</TT
> are very powerful. In fact, they
    are even used in assembling software used to create animated
    films. Animation means a lot of intensive work for your computer,
    though, and Python can not always cope&#8212;even on the most
    modern machines. In such cases, it is quite easy to replace the
    Python class with a Qt-based C++ object (you won't have to
    translate your whole Python application). See <A href="a8834.htm">Appendix C</A
>
    for information on the wrapping of new C++ objects with sip.</P
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
>Working with painters and paint devices</A
></H1
><P
>In <A href="c2591.htm">Chapter 10</A
> we introduced
      <TT
CLASS="CLASSNAME"
>QPainter</TT
>, for creating our little
      scribbling example application, <TT
CLASS="FILENAME"
>event1.py</TT
>.
      In this section we will take a closer look at the organization
      and use of the PyQt painting mechanism.</P
><P
>Painting in PyQt involves the cooperation
      of two classes: a <TT
CLASS="CLASSNAME"
>QPainter</TT
> and a
      <TT
CLASS="CLASSNAME"
>QPaintDevice</TT
>. The first is a very
      efficient abstraction of various drawing operations. It provides
      the brushes and the letterpress, so to speak. The second
      provides the &#8216;paper' on which to draw.</P
><P
>There are four subclasses of
      <TT
CLASS="CLASSNAME"
>QPaintDevice</TT
>:
      <TT
CLASS="CLASSNAME"
>QWidget</TT
>, <TT
CLASS="CLASSNAME"
>QPicture</TT
>,
      <TT
CLASS="CLASSNAME"
>QPixMap</TT
> and
      <TT
CLASS="CLASSNAME"
>QPrinter</TT
>.</P
><P
>You use hand-coded painting with a
      <TT
CLASS="CLASSNAME"
>QPainter</TT
> object on a
      <TT
CLASS="CLASSNAME"
>QWidget</TT
> to determine the look of a widget.
      The place for the painting code is in re-implementations of the
      <TT
CLASS="FUNCTION"
>paintEvent()</TT
> function.</P
><P
><TT
CLASS="CLASSNAME"
>QPicture</TT
> is a kind
      of event recorder: it records every
      <TT
CLASS="CLASSNAME"
>QPainter</TT
> action, and can replay them. You
      can also save those actions to a platform independent file. This
      is useful if you want to implement rolling charts with a limited
      replay functionality (although <SPAN
><I
CLASS="EMPHASIS"
>I</I
></SPAN
> would
      prefer to save the underlying data and reconstruct the chart
      every time). You cannot alter anything in the sequence of events
      once it is recorded. Starting with Qt 3,
      <TT
CLASS="CLASSNAME"
>QPicture</TT
> has become quite powerful, with
      the ability to load and save industry standard
      <TT
CLASS="FILENAME"
>.svg</TT
> files - the scalable vector graphics
      format.</P
><P
>Painting on a
      <TT
CLASS="CLASSNAME"
>QPixMap</TT
> is extraordinarily useful.
      Painting is always a bit slow, especially if it is done line by
      line, dot by dot, and character by character. This can result in
      visible lag or flickering if you paint directly on an exposed
      <TT
CLASS="CLASSNAME"
>QWidget</TT
>. By first painting the complete
      drawing on a <TT
CLASS="CLASSNAME"
>QPixMap</TT
> object, and then
      using the <TT
CLASS="FUNCTION"
>bitBlt()</TT
> function to move the
      picture in one swoop the the widget, you will avoid this
      flickering. <TT
CLASS="CLASSNAME"
>bitBlt()</TT
> really
      <SPAN
><I
CLASS="EMPHASIS"
>is</I
></SPAN
> fast.</P
><P
>Finally, being able to paint on a
      <TT
CLASS="CLASSNAME"
>QPrinter</TT
> object means that anything you
      can draw on-screen can also be printed. However, printing is
      still quite a difficult subject &#8212; even if PyQt can
      generate your PostScript for you, you still have to layout
      everything yourself. You cannot, for instance, send the contents
      of a <TT
CLASS="CLASSNAME"
>QSimpleRichText</TT
> widget to a printer
      just like that... We'll discuss the basics of printing in
      <A href="c8100.htm">Chapter 24</A
>.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>A painting example</A
></H2
><P
>There is little we can do using
        <TT
CLASS="CLASSNAME"
>QPainter</TT
> and
        <TT
CLASS="CLASSNAME"
>QPaintDevices</TT
> in our
        <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
> project &#8212; but after
        long and hard thinking I thought a rolling chart that counts
        how many characters the user types per minute might be a nice,
        although completely useless (and possibly frustrating) except
        for <SPAN
><I
CLASS="EMPHASIS"
>real</I
></SPAN
> productivity freaks.</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 21-1. typometer.py - A silly type-o-meter that keeps a
          running count of how many characters are added to a certain
          document and shows a chart of the typerate...</B
></P
><PRE
CLASS="PROGRAMLISTING"
>"""
typometer.py

A silly type-o-meter that keeps a running count of how many characters there
are in a certain document and shows a chart of the count...
"""
import sys, whrandom
from qt import *

FIVE_SECONDS = 1000 * 5 #  5 seconds in milli-seconds
AVERAGE_TYPESPEED = 125 # kind of calibration
BARWIDTH = 3

TRUE=1
FALSE=0
          </PRE
></DIV
><P
>No surprises here&#8212;just some
        declarations. I like to work with names instead of magic
        numbers, and to conform to practice in other programming
        languages, those names are in all-caps, even though they are
        not constants.</P
><PRE
CLASS="PROGRAMLISTING"
>class TypoGraph(QPixmap):
    """ TypoGraph is a subclass of QPixmap and draws a small graph of
    the current wordcount of a text.
    """
    def __init__(self, count, w, h, *args):
        apply(QPixmap.__init__, (self, w, h) + args)
        self.count = count
        self.maxCount = AVERAGE_TYPESPEED
        if count != 0:
            self.scale = float(h) / float(count)
        else:
            self.scale = float(h) / float(AVERAGE_TYPESPEED)
        self.col = 0
        self.fill(QColor("white"))
        self.drawGrid()
      </PRE
><P
>The general design of this chart drawing
        code consists of two parties: a specialized pixmap, descended
        from <TT
CLASS="CLASSNAME"
>QPixmap</TT
>, that will draw the chart
        and keep track of scrolling, and a widget that show the chart
        and can be used everywhere where you might want to use a
        widget.</P
><P
>In the constructor of
        <TT
CLASS="CLASSNAME"
>TypoGraph</TT
>, the specialized
        <TT
CLASS="CLASSNAME"
>QPixMap</TT
>, certain initial variables are
        set. One point of attention is scaling. The chart will have a
        certain fixed vertical size. It is quite possible that the
        plotted values won't fit into the available pixels.</P
><P
>This means that we have to scale the
        values to fit the pixels of the chart. This is done by
        arbitrarily deciding upon a maximum value, and dividing the
        height of the chart by that value. Any value greater than the
        maximum will go off the chart, but if you can type more than
        125 characters in five seconds, you deserve to fly off the
        chart!</P
><P
>Because the scaling can be smaller than
        one but greater than zero, we need to use
        <SPAN
><I
CLASS="EMPHASIS"
>float</I
></SPAN
> numbers for our scale. Floats are
        notoriously slow, but believe me, your computer can handle
        more floats than you can throw at it per second, so you won't
        feel the penalty for not using integers.</P
><P
>Finally, we fill the pixmap with a
        background color (white in this case) and draw a nice
        grid:</P
><PRE
CLASS="PROGRAMLISTING"
>    def drawGrid(self):
        p = QPainter(self)
        p.setBackgroundColor(QColor("white"))
        h = self.height()
        w = self.width()
        for i in range(1, h, h/5):
            p.setPen(QColor("lightgray"))
            p.drawLine(0, i, w, i)
      </PRE
><P
>This is the first encounter with
        <TT
CLASS="CLASSNAME"
>QPainter</TT
>. The basic procedure for
        working with painter objects is very simple: you create a
        painter for the right paintdevice. Here the paintdevice is
        <TT
CLASS="VARNAME"
>self</TT
> &#8212; our specialized
        <TT
CLASS="CLASSNAME"
>QPixMap</TT
>. After having created the
        <TT
CLASS="CLASSNAME"
>QPainter</TT
> you can mess about drawing
        lines, setting colors or throwing more complex shapes on the
        paper. Here, we draw four lines at equal distances using a
        light-gray pen. The distance is computed by letting the
        <TT
CLASS="FUNCTION"
>range</TT
> function use the height of the
        widget divided by the number of rows we want as a
        stepsize.</P
><P
>If you wish to use several different
        painter objects, you might want to use the
        <TT
CLASS="FUNCTION"
>begin()</TT
> and <TT
CLASS="FUNCTION"
>end()</TT
>
        methods of the <TT
CLASS="CLASSNAME"
>QPainter</TT
> class. In
        normal use, as here, the <TT
CLASS="FUNCTION"
>begin()</TT
> function
        is called when the <TT
CLASS="CLASSNAME"
>QPainter</TT
> is created,
        and <TT
CLASS="FUNCTION"
>end()</TT
> when it is destroyed. However,
        because the reference goes out of scope,
        <TT
CLASS="FUNCTION"
>end()</TT
> is called automatically, so you
        won't have to call <TT
CLASS="FUNCTION"
>end()</TT
> yourself.</P
><PRE
CLASS="PROGRAMLISTING"
>    def text(self):
        return QString(str(self.count))
      </PRE
><P
>The function <TT
CLASS="FUNCTION"
>text()</TT
>
        simply returns a <TT
CLASS="CLASSNAME"
>QString</TT
> object
        containing the last plotted value. We will use this to set the
        caption of the chart window.</P
><PRE
CLASS="PROGRAMLISTING"
>    def update(self, count):
        """
        Called periodically by a timer to update the count.
        """
        self.count = count

        h = self.height()
        w = self.width()

        p = QPainter(self)
        p.setBackgroundColor(QColor("white"))

        p.setBrush(QColor("black"))
        
        if self.col &#62;= w:
            self.col = w
            # move one pixel to the left
            pixmap = QPixmap(w, h)
            pixmap.fill(QColor("white"))
            bitBlt(pixmap, 0, 0,
                   self, BARWIDTH, 0, w - BARWIDTH, h)
            
            bitBlt(self, 0, 0, pixmap, 0, 0, w, h)
            for i in range(1, h, h/5):
                p.setPen(QColor("lightgray"))
                p.drawLine(self.col - BARWIDTH , i, w, i)
        else:
            self.col += BARWIDTH

        y = float(self.scale) * float(self.count)
        # to avoid ZeroDivisionError
        if y == 0: y = 1

        # Draw gradient
        minV = 255
        H = 0
        S = 255

        vStep = float(float(128)/float(y))
        for i in range(y):
            color = QColor()
            color.setHsv(H, S, 100 + int(vStep * i))
            p.setPen(QPen(color))
            p.drawLine(self.col - BARWIDTH, h-i, self.col, h-i)
      </PRE
><P
>The <TT
CLASS="FUNCTION"
>update()</TT
>
        function is where the real meat of the charting pixmap is. It
        draws a gradiented bar that scrolls left when the right side
        is reached (that is, if the current column has arrived at or
        gone beyond the width of the pixmap).</P
><P
>The scrolling is done by creating a new,
        empty <TT
CLASS="CLASSNAME"
>QPixmap</TT
> and blitting the right
        hand part of the old pixmap onto it. When writing this code, I
        noticed that you cannot blit a pixmap onto itself. So, after
        we've created a pixmap that contains the old pixmap minus the
        first few vertical lines, we blit it back, and add the grid to
        the now empty right hand side of the pixmap.</P
><P
>The height of the bar we want to draw is
        computed by multiplying the value
        (<TT
CLASS="VARNAME"
>self.count</TT
>) with the scale of the chart.
        If the result is 0, we make it 1.</P
><P
>We draw the bar in steps, with each step
        having a subtly differing color from the one before it. The
        color gradient is determined by going along the
        <SPAN
><I
CLASS="EMPHASIS"
>value</I
></SPAN
> range of a hue-saturation-value
        color model. Value determines darkness, with 0 being
        completely dark, and 255 completely light. We don't use the
        complete range, but step directly from 100 (fairly dark) to
        228 (quite bright). The step is computed by dividing the value
        range we want (128) by the height of the bar. Every bar is
        going from 100 to 228.</P
><P
>Then we step through the computed height
        of the bar, drawing a horizontal line with the length of the
        bar thickness &#8212; <TT
CLASS="VARNAME"
>BARWIDTH</TT
>.</P
><P
>Computing gradients is fairly costly,
        but it is still possible to type comfortably when this chart
        is running: a testimony to the efficient design of
        <TT
CLASS="CLASSNAME"
>QPainter</TT
>. If your needs are more
        complicated, then <TT
CLASS="CLASSNAME"
>QPainter</TT
> offers a
        host of sophisticated drawing primitives (and not so
        primitives, like shearing, scaling, resizing and the drawing
        of quad beziers).</P
><P
>The <TT
CLASS="CLASSNAME"
>TypoGraph</TT
> is
        completely generic: it draws a nicely gradiented graph of any
        values that you feed the update function. There's some testing
        code included that uses a simple timer to update the chart
        with a random value.</P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>A stand-alone chart</P
></DIV
></P
></DIV
><P
>More application-specific is the
        <TT
CLASS="CLASSNAME"
>TypoMeter</TT
> widget, which keeps track of
        all open <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
> documents, and shows
        the right chart for the currently active document.</P
><PRE
CLASS="PROGRAMLISTING"
>class TypoMeter(QWidget):

    def __init__(self, docmanager, workspace, w, h, *args):
        apply(QWidget.__init__, (self,) + args)

        self.docmanager = docmanager
        self.workspace = workspace

        self.resize(w, h)
        self.setMinimumSize(w,h)
        self.setMaximumSize(w,h)

        self.h = h
        self.w = w

        self.connect(self.docmanager,
                     PYSIGNAL("sigNewDocument"),
                     self.addGraph)
        self.connect(self.workspace,
                     PYSIGNAL("sigViewActivated"),
                     self.changeGraph)
        self.graphMap = {}
        self.addGraph(self.docmanager.activeDocument(),
                      self.workspace.activeWindow())

        self.timer = QTimer(self)
        self.connect(self.timer,
                     SIGNAL("timeout()"),
                     self.updateGraph)
        self.timer.start(FIVE_SECONDS, FALSE)
      </PRE
><P
>In order to implement this feature, some
        new signals had to be added to the document manager and the
        workspace classes. Note also the use of the
        <TT
CLASS="CLASSNAME"
>QTimer</TT
> class. A timer is created with
        the current object as its parent; a slot is connected to the
        <TT
CLASS="FUNCTION"
>timeout()</TT
> signal, and the timer is
        started with a certain interval. The <TT
CLASS="VARNAME"
>FALSE</TT
>
        parameter means that the timer is supposed to keep running,
        instead of firing once, when the timeout is reached.</P
><PRE
CLASS="PROGRAMLISTING"
>    def addGraph(self, document, view):
        self.currentGraph = TypoGraph(0,
                                      self.h,
                                      self.w)
        self.graphMap[document] = (self.currentGraph, 0)
        self.currentDocument = document


    def changeGraph(self, view):
        self.currentGraph = self.graphMap[view.document()][0]
        self.currentDocument = view.document()
        bitBlt(self, 0, 0,
               self.currentGraph,
               0, 0,
               self.w,
               self.h)

    def updateGraph(self):

        prevCount = self.graphMap[self.currentDocument][1]
        newCount = self.currentDocument.text().length()
        self.graphMap[self.currentDocument] = (self.currentGraph, newCount)

        delta = newCount - prevCount

        if delta &#60; 0: delta = 0 # no negative productivity

        self.currentGraph.update(delta)

        bitBlt(self, 0, 0,
               self.currentGraph,
               0, 0,
               self.w,
               self.h)
        self.setCaption(self.currentGraph.text())
      </PRE
><P
>The actual keeping track of the
        type-rate is done in this class, not in the
        <TT
CLASS="CLASSNAME"
>TypoChart</TT
> class. In making good use of
        Python's ability to form tuples on the fly, a combination of
        the <TT
CLASS="CLASSNAME"
>TypoChart</TT
> instance and the last
        count is kept in a dictionary, indexed by the document.</P
><P
>Using the last count and the current
        length of the text, the <SPAN
><I
CLASS="EMPHASIS"
>delta</I
></SPAN
> (the
        difference) is computed and fed to the chart. This updates the
        chart, and the chart is then blitted onto the widget &#8212; a
        <TT
CLASS="CLASSNAME"
>QWidget</TT
> is a paintdevice, after
        all.</P
><PRE
CLASS="PROGRAMLISTING"
>    def paintEvent(self, ev):
        p = QPainter(self)
        bitBlt(self, 0, 0,
               self.currentGraph,
               0, 0,
               self.w,
               self.h)

class TestWidget(QWidget):

    def __init__(self, *args):
        apply(QWidget.__init__, (self,) + args)
        self.setGeometry(10, 10, 50, 250)
        self.pixmap = TypoGraph(0, self.width(), self.height())
        self.timer = self.startTimer(100)

    def paintEvent(self, ev):
        bitBlt(self, 0, 0, self.pixmap, 0, 0, self.width(), self.height())

    def timerEvent(self, ev):
        self.pixmap.update(whrandom.randrange(0, 300))
        bitBlt(self, 0, 0, self.pixmap, 0, 0, self.width(), self.height())

if __name__ == '__main__':
    a = QApplication(sys.argv)
    QObject.connect(a,SIGNAL('lastWindowClosed()'),a,SLOT('quit()'))
    w = TestWidget()
    a.setMainWidget(w)
    w.show()
    a.exec_loop()
      </PRE
><P
>Finally, this is some testing code, not
        for the <TT
CLASS="CLASSNAME"
>TypoMeter</TT
> class, which can only
        work together with <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
>, but for
        the <TT
CLASS="CLASSNAME"
>TypoChart</TT
> class. It is difficult to
        use the unit testing framework from <A href="c5064.htm">Chapter 14</A
>
        here&#8212; after all, in the case of graphics work, the proof
        of the pudding is in the eating, and it's difficult to assert
        things about pixels on the screen.</P
><P
>The code to show the type-o-meter on
        screen is interesting, since it shows how you can
        destructively delete a widget. The
        <TT
CLASS="CLASSNAME"
>QAction</TT
> that provides the menu option
        "show type-o-meter" is a toggle action, and changing the
        toggle emits the <TT
CLASS="FUNCTION"
>toggled(bool)</TT
> signal.
        This is connected to the following function (in
        <TT
CLASS="FILENAME"
>kalamapp.py</TT
>: </P
><PRE
CLASS="PROGRAMLISTING"
>    def slotSettingsTypometer(self, toggle):
        if toggle:
            self.typowindow = TypoMeter(self.docManager,
                                        self.workspace,
                                        100,
                                        100,
                                        self,
                                        "type-o-meter",
                                        Qt.WType_TopLevel or Qt.WDestructiveClose)
            self.typowindow.setCaption("Type-o-meter")
            self.typowindow.show()
        else:
            self.typowindow.close(TRUE)
      </PRE
><P
>Destroying this popup-window is
        important, because you don't want to waste processing power on
        a widget that still exists and is merely hidden. The character
        picker popup we will create in the next section will be
        hidden, not destroyed.</P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A accesskey="P" href="x7388.htm">Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="H" href="book1.htm">Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A accesskey="N" href="x7601.htm">Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Conclusion</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="U" href="p4627.htm">Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>QCanvas</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
      </td>
      </tr>
      </table>
      </td>
    </tr>
  </table>
  
    
