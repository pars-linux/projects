

  
  <table border="0" cellspacing="0" cellpadding="3" width="100%"><tr><td>
    <div align="center" id="bldcontent">
      <a href="http://www.opendocspublishing.com/"><img src="../images/opendocs.png" width="63" height="76" border="0"></a>
      <br>
      <div class="symbol">Your OpenSource Publisher&#153;</div>
    </div>
    
  </td></tr></table>
  
  <div align="center" class="author">
      	<a href="../products.lxp.html">Products</a>
	&nbsp;|&nbsp;
	<a href="../wheretobuy.lxp.html">Where to buy</a>
	&nbsp;|&nbsp;
	<a href="../bookstore.lxp.html">Retailers</a>
	&nbsp;|&nbsp;
	<a href="../FAQ.lxp.html">FAQ</a>
	&nbsp;|&nbsp;
        <a href="../writeforus.lxp.html">Write for Us.</a>
        &nbsp;|&nbsp;
        <a href="x4274.htm#contact">Contact Us.</a>
  </div>
    <table border="0" cellspacing="3" cellpadding="0" width="100%"><tr><td width="100%">
      <div class="content">
        <table border="0" cellspacing="2" cellpadding="0" width="100%"><tr><td width="100%">
          <div align="center">
<H4 CLASS="AUTHOR"><A NAME="AEN5">Boudewijn Rempt</A>
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
<img src="ODPyQT125.png">
</a>
<br>
ISBN: 0-97003300-4-4
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
Available from bookstores everywhere or you can order it here.
</a>
<p>
You can download the source files for the book <a href="pyqtsrc.tgz">(code / eps) here.</a>
<hr>
</div>

          
          <HTML
><HEAD
><TITLE
>Advanced Designer topics</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.72
"><LINK
REL="HOME"
TITLE="GUI Programming with Python: QT Edition"
HREF="book1.htm"><LINK
REL="UP"
TITLE="Qt Designer, BlackAdder and uic"
HREF="c4079.htm"><LINK
REL="PREVIOUS"
TITLE="Qt Designer, BlackAdder and uic"
HREF="c4079.htm"><LINK
REL="NEXT"
TITLE="Creating real applications with PyQt"
HREF="p4627.htm"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GUI Programming with Python: QT Edition</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A accesskey="P" href="c4079.htm">Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 11. Qt Designer, BlackAdder and uic</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A accesskey="N" href="p4627.htm">Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
>Advanced Designer topics</A
></H1
><P
>In this section, I will discuss more advanced topics in
      working with BlackAdder Designer. These are: the connecting of
      the individual widgets in your design using signals and slots,
      the adding of custom widgets to the BlackAdder Designer palette,
      and the actual generation and use of code with BlackAdder and
      with the command-line utility pyuic. Finally, I will give some
      attention to the generation of C++ code.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>Defining signals and slots in Designer</A
></H2
><P
>The widgets on a form often have a relationship to each
        other. For instance, the <SPAN
CLASS="GUIBUTTON"
>OK</SPAN
> button should ask
        the form to close. Clicking on a button should move selected
        items from one <TT
CLASS="CLASSNAME"
>QListView</TT
> to another. As
        you have seen before, the standard way of linking widgets in
        PyQt is by connecting signals with slots. You can create these
        connections by simply drawing a line in BlackAdder designer.
      </P
><P
>The first step is to create a design. Based on the
        <SPAN
><I
CLASS="EMPHASIS"
>DIalog with Buttons (right)</I
></SPAN
> template, we
        add two <TT
CLASS="CLASSNAME"
>QListBox</TT
>es and four buttons:</P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>Initial design.</P
></DIV
></P
></DIV
><P
> If you right-click on the form, and then choose
      <SPAN
CLASS="GUIMENUITEM"
>Connections</SPAN
>, you will see that there
      are already two connections made, namely between the
      <SPAN
CLASS="GUIBUTTON"
>OK</SPAN
> button and the
      <SPAN
CLASS="GUIBUTTON"
>Cancel</SPAN
> button. It is our task to create
      more connections.</P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>The two initial connections.</P
></DIV
></P
></DIV
><P
>The goal of the buttons is to move items
        from the left listbox to the right listbox, and back.
        Double-arrowed buttons move everything, and single-arrowed
        buttons move the selection. Select the connection button (
        <IMG
SRC="ch7/connection_button.eps">), and draw a line from the top button to any
        place on the form. A dialog pops up that lets you select from
        the signals of the button and the slots of the form. However,
        there is no slot available that says something useful like
        <TT
CLASS="FUNCTION"
>slotAddAllFromLeftToRight()</TT
>!</P
><P
>Does this mean that you are restricted to
        the slots as defined in the PyQt library? Fortunately, no. You
        can add your own slots &#8212; but only to the form, not to
        the individual widgets. This is actually quite logical; later,
        you will generate a Python class from the
        <TT
CLASS="FILENAME"
>.ui</TT
> design. You then subclass the
        generated Python code to add functionality.  Since you will
        only subclass the form, the form is the only place you will be
        able to add slots. If you want custom slots in your widgets,
        you will have to add custom widgets to Designer.</P
><P
>Your subclass will be a descendant of the
        entire form, so you can only add functionality to the form,
        not to the widgets. Of course, you can also create custom
        widgets with custom signals and slots, and use those instead
        of the standard <TT
CLASS="CLASSNAME"
>QListBox</TT
>. I will
        discuss the technique for adding custom widgets in the next
        section.</P
><P
>Lets go ahead and add our custom slots to
        the form. This is quite easy. Select the
        <SPAN
CLASS="GUIMENUITEM"
>Slots</SPAN
> menu item from the
        <SPAN
CLASS="GUIMENU"
>Edit</SPAN
> menu, and press the <SPAN
CLASS="GUIBUTTON"
>New
          Slot</SPAN
> button. Now you can edit the text in the
        <SPAN
CLASS="GUIBUTTON"
>Slot Properties</SPAN
> text field. Type the
        name of the slot, and then enter the
        <SPAN
><I
CLASS="EMPHASIS"
>types</I
></SPAN
> of the arguments the slot should be
        called with, between brackets. This is not useful in our case,
        since we will call the slots with the
        <TT
CLASS="FUNCTION"
>clicked()</TT
> signal of the buttons, and
        these don't pass on an argument.</P
><P
>Define the following four slots:</P
><P
></P
><UL
><LI
><P
>slotAddAll()</P
></LI
><LI
><P
>slotAddSelection()</P
></LI
><LI
><P
>slotRemoveAll()</P
></LI
><LI
><P
>slotRemoveSelection()</P
></LI
></UL
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>All slots are defined.</P
></DIV
></P
></DIV
><P
>Now, you can connect the <TT
CLASS="FUNCTION"
>clicked()</TT
> signal of
        each button to the right slot.</P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>All connections are made.</P
></DIV
></P
></DIV
><P
>The Access specifier in the slot definition dialog is only
        important if you want to migrate your designs to C++ at some
        time. "Public" means that all classes in your C++ program have
        access to those slots; protected means that only the generated
        class itself and its subclasses can access the slot.
        &#8216;Protected is as if the slotname were prefixed with a double
        underscore in Python.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>Adding your own widgets</A
></H2
><P
>Not only can you add your own slots to the forms you
        design with BlackAdder, but you can also create custom widgets,
        and use those widgets in other designs. The design shown in
        the previous section &#8212; two listboxes and a few buttons to move
        items from left to right, and vice-versa &#8212; is something that's
        quite often needed, and is a prime candidate to turn into a
        widget.</P
><P
>Open the <TT
CLASS="FILENAME"
>connections.ui</TT
> file, and
        create a new <TT
CLASS="FILENAME"
>.ui</TT
> file based on the widget
        template. Copy everything from the form to the widget, except,
        of course, the <SPAN
CLASS="GUIBUTTON"
>OK</SPAN
>,
        <SPAN
CLASS="GUIBUTTON"
>Cancel</SPAN
> and <SPAN
CLASS="GUIBUTTON"
>Help</SPAN
>
        buttons. Perhaps you will have to do the layout again; if so, use a
        grid layout. Create the slots again, this time for the widget,
        and connect them.</P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>The DoubleListBox widget design.</P
></DIV
></P
></DIV
><P
>Choose <SPAN
CLASS="GUIMENUITEM"
>Compile Form</SPAN
> from the
        <SPAN
CLASS="GUIMENU"
>File</SPAN
> menu. This will generate a Python file that
        implements your design. For now, this is enough. As I will show later,
        you should subclass the generated Python file and add some real
        logic, and perhaps a few signals.</P
><P
>For now, we have a custom component, designed with BlackAdder and
        implemented in Python. This component we will add to the BlackAdder
        components palette, and use it in a dialog.</P
><P
>Choose <SPAN
CLASS="GUIMENUITEM"
>Edit Custom Widgets</SPAN
> from the
        <SPAN
CLASS="GUISUBMENU"
>Custom</SPAN
> submenu in the <SPAN
CLASS="GUIMENU"
>Tools</SPAN
>
        menu. This will open a rather complicated dialog that lets you add new
        widgets.</P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>Adding a custom widget.</P
></DIV
></P
></DIV
><P
>You must type the name of the Python class &#8212; in this case
        <TT
CLASS="CLASSNAME"
>DoubleListBox</TT
> &#8212; in the Class text field. The
        headerfile text field refers ostensibly to a C++ header file; but
        BlackAdder assumes that it refers to a Python file. Enter
        <TT
CLASS="FILENAME"
>wdglistbox</TT
>, if that is the name you saved your
        custom widget under. Do not add the extension. The choice between local
        and global only has a meaning for C++ and defines the type of
        include.</P
><P
>The rest of the fields are less vital. You can create a
        pixmap that represents your widget; if you don't, the green
        Trolltech logo will take be used a placeholder.  You can give
        a default size hint and size policy. For example, if you want the double
        listbox to take as much space as it can get, set both
        policies to <SPAN
><I
CLASS="EMPHASIS"
>expanding</I
></SPAN
>. Our double listbox
        cannot contain other widgets (it is not like a groupbox), and
        therefore we don't check the <SPAN
CLASS="GUIBUTTON"
>Container
          Widget</SPAN
> checkbox.</P
><P
>In the other tabs, we can enter the slots and signals that our
        widget knows; this is only useful for slots and widgets that
        have a meaning to the outside world. The four special slots defined in
        the previous section are for internal use. In a subclass of
        DoubleListBox, we might define a few extra signals, like:</P
><P
></P
><UL
><LI
><P
>sigItemAdded(ListViewItem)</P
></LI
><LI
><P
>sigItemDeleted(ListViewItem)</P
></LI
></UL
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>Adding signals to a custom widget.</P
></DIV
></P
></DIV
><P
>Note that we give a listviewitem as an argument to these signals;
        Python signals do have arguments, but they are untyped. Slots are not
        relevant for this widget, and neither are properties.</P
><P
>If you press <SPAN
CLASS="GUIBUTTON"
>OK</SPAN
> a new item
        will be added to the toolbars, which you can select and put on
        a form. If you do so, you will see that the icon is also used
        to represent the widget on the form, instead of a more
        faithful representation of the widget. When you preview the
        form, you won't see the widget either; but wen you generate the
        form, everything will be all right.</P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>A form using the DoubleListBox custom widget..</P
></DIV
></P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>Layout management</A
></H2
><P
>It is possible to design your dialogs and
        widgets by plonking down elements, sizing them to your liking
        and placing them where you want, down to the last pixel. If
        you fix the size of the form and the  font, you can have a
        perfect layout &#8212; but it will also be a layout that your
        users won't like. People want to resize dialogs, either to
        have more data visible at the same time, or to minimize the
        amount of space the dialog takes on their already crowded
        screens. Visually impaired users want to change the font size
        to something they <SPAN
><I
CLASS="EMPHASIS"
>can</I
></SPAN
> see. Furthermore,
        there are vast differences in default fonts between Windows
        systems and some other systems, like KDE, which define a
        different default font dependent upon screen resolution. Your
        pixel-precise dialog won't look so good if the user views it
        with a font that he chooses, not in terms of pixel size, but
        of points per inch &#8212; where an inch can have between 75
        and 120 pixels. A twelve-point Helvetica has a lot more pixels
        if generated for a resolution of 120 pixels to the inch, then
        if it were generated for 75 pixels to the inch.</P
><P
>All these are good reasons to let the
        computer manage the layout for you. There are other reasons,
        too. With complex forms, doing the layout yourself quickly
        becomes a bore. If your application is used by people with a
        right-to-left alphabet, like Hebrew or Arabic, the whole
        layout should be mirrored. From version 3, Qt can do that for
        you, if only you let Qt manage your layouts. The same goes for the
        size of labels. If you pixel-position your controls to the
        width of the labels, then there won't be room for languages
        that use &#8216;fichier' for &#8216;file', or
        &#8216;annuleren' for &#8216;cancel'.</P
><P
>All these arguments have never before
        swayed developers to use automatic layout management, but with
        PyQt and BlackAdder, layout management is ridiculously easy
        (and certainly easier than manual layout). This, at least,
        should convert the developing masses to automatic
        layouting!</P
><P
>The Designer module of BlackAdder offers
        three layout managers, and a helpful tool called the
        <SPAN
><I
CLASS="EMPHASIS"
>spacer</I
></SPAN
>. The layout managers are:</P
><P
></P
><UL
><LI
><P
>horizontal</P
></LI
><LI
><P
>vertical</P
></LI
><LI
><P
>grid</P
></LI
></UL
><P
>By nesting layouts, together with the
        spacer and the sizepolicies and sizehints of each individual
        widget, you can create almost any layout. A good rule of thumb
        is perhaps that if your intended layout confuses the layout
        managers of the Designer, then it will probably also confuse
        your users.</P
><P
>A good layout is one that can be easily
        taken in with one look, and that neatly groups the various
        bits of data in the form. A good layout will also be simple
        enough that the form won't take an eternity to appear. Bear in
        mind that Python has to load the form, lay it out, and, most
        importantly, fill the various fields with relevant the data.
        The last step can take a lot of time. I once had to create a
        form that brought together about sixty pieces of information
        from more than twenty database tables. My client was not
        pleased when this form wouldn't appear in the required three
        seconds.</P
><P
>I've already discussed the classes behind
        the horizontal, vertical and grid layout managers:
        <TT
CLASS="CLASSNAME"
>QLayout</TT
>,
        <TT
CLASS="CLASSNAME"
>QBoxLayout</TT
>,
        <TT
CLASS="CLASSNAME"
>QVBoxLayout</TT
>,
        <TT
CLASS="CLASSNAME"
>QHBoxLayout</TT
> and
        <TT
CLASS="CLASSNAME"
>QGridLayout</TT
>.</P
><P
>You can influence the layouts by
        selecting them in the object hierarchy window. Interesting
        properties include <SPAN
><I
CLASS="EMPHASIS"
>LayoutSpacing</I
></SPAN
> and
        <SPAN
><I
CLASS="EMPHASIS"
>LayoutMargin</I
></SPAN
>. The first determines how
        much room there is between widgets; the second determines how
        much space the layout wants between itself and the border of
        the window or other layouts.</P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>Layout manager properties.</P
></DIV
></P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
>The Horizontal Layout Manager</A
></H3
><P
>The horizontal layout manager lays the
          widgets out in one row, like the individual menu's in a menu
          bar, or the buttons at the bottom of a form based on the
          <SPAN
><I
CLASS="EMPHASIS"
>Dialog With Buttons (Bottom)</I
></SPAN
> dialog.
        </P
><P
>There are few widgets that are
          customarily laid out horizontally, most often widgets are
          grouped in vertical columns. The columns themselves can be
          grouped in a horizontal layout manager.
        </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
>The Vertical Layout Manager</A
></H3
><P
>The vertical layout manager puts
          widgets in one column. This can be very useful when creating
          a groupbox that contains radio buttons or checkboxes. You
          will very seldom want to layout radio buttons in a
          horizontal row. Another use is the column of buttons in the
          <SPAN
><I
CLASS="EMPHASIS"
>Dialog with Buttons (right)</I
></SPAN
> template.
        </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
>The Grid Layout Manager</A
></H3
><P
>The Grid Layout managers lays out your
          widgets in a square or oblong grid. If you want everything
          in your form to be managed in a grid, then you can simply
          select this layout manager from the toolbar, and then click
          somewhere on the background of the form. The Designer module
          is <SPAN
><I
CLASS="EMPHASIS"
>very</I
></SPAN
> clever, and will try to retain
          your current, manually created layout as far as possible. It
          can even create the difficult multi-column widgets
          automatically.
          </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
>The Spacer object</A
></H3
><P
>Of course, for all its cleverness, there
          are situations when the Designer simply cannot determine
          your meaning without some help. There is no Intention Layout
          Manager! One useful tool to let the layout manager know your
          intention is the spacer object. This is an invisible (at
          runtime) widget that pushes other widgets away. You can use
          a spacer either horizontally or vertically. If you use a
          spacer at both sides of a widget, they will push the widget
          to the middle. If you use only one spacer, it will push the
          widget to the other side.
          </P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>Playing with spacers.</P
></DIV
></P
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
>What widgets can do to get the space they want</A
></H3
><P
>Not every widget wants to hog all the space
          in a dialog. A combobox, for instance, has no reason to grow
          vertically, while a vertical scrollbar doesn't need to get
          any wider. You can set the horizontal and vertical
          sizepolicies of your widgets in the Designer
          module.</P
><P
>However, this will not always produce the results
          you want &#8212; in such a case, you might be reduced to setting
          minimum and maximum pixel widths by hand. This may be necessary
          if you have a listbox or combobox that expands without
          limit because one of the entries is as long as a fantasy
          trilogy without linebreaks. To curb the tendency of the
          listbox to usurp all the space in the dialog, you should set
          its maximum width to something sensible. Note also that,
          alas, the layout management of the forms in the designer
          doesn't work exactly the same as the layout management of
          the running forms. You can see the difference in the preview
          mode.
        </P
><P
>The sizepolicy works in concord with
          the result of calls to the <TT
CLASS="FUNCTION"
>sizeHint ()</TT
>
          function &#8212; this function returns the size the widget
          wants to be, and the <TT
CLASS="FUNCTION"
>minimumSizeHint()</TT
>
          function, which returns the absolute minimum size the widget
          can be. The following hints can be used for setting the
          sizepolicy of widgets:</P
><P
></P
><UL
><LI
><P
>fixed &#8212; what
              <TT
CLASS="FUNCTION"
>sizeHint()</TT
> says is law &#8212;
              smaller nor larger is acceptable.
            </P
></LI
><LI
><P
>minimum &#8212; the result of
              <TT
CLASS="FUNCTION"
>sizeHint()</TT
> is sufficient. It cannot
              be smaller, might be larger, but there's no use in
              growing.
            </P
></LI
><LI
><P
>maximum &#8212; what
              <TT
CLASS="FUNCTION"
>sizeHint()</TT
> returns is the max
              &#8212; the widget should not be expanded, but might be
              shrunk without detriment.
            </P
></LI
><LI
><P
>preferred &#8212; the
              <TT
CLASS="FUNCTION"
>sizeHint()</TT
> size is best, but the
              widget can be smaller without problems. It might be
              larger, but there's no earthly reason why it should.
            </P
></LI
><LI
><P
>minimumExpanding &#8212; the
              widget wants as much space as it can get &#8212; the
              more it gets, the better. No way it should shrink.
            </P
></LI
><LI
><P
>Expanding &#8212; the widget wants
              as much space as it can get, but it's still useful if it
              get less than the result of
              <TT
CLASS="FUNCTION"
>sizeHint()</TT
>.
            </P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
>Creating a complex form</A
></H3
><P
>          Let's try to create a really complicated form, just to see
          what the automatic layout engine can do.
        </P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>A quite complex dialog.</P
></DIV
></P
></DIV
><P
>This dialog was created in the following steps:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Create a new form &#8212; based
              the simple Dialog Template.
            </P
></LI
><LI
><P
>Create two pushbuttons and place
              them at the right top.
            </P
></LI
><LI
><P
>Create a vertical spacer item,
              below the buttons.
            </P
></LI
><LI
><P
>Collect the buttons and the spacer
              in a rubber band and select the vertical layout manager.
              Resize the layout to the height of the dialog.
            </P
></LI
><LI
><P
>Create the three listboxes, and
              resize them to roughly about the right size; put the
              three line editors below.
            </P
></LI
><LI
><P
>Select the listboxes and the
              lineedits in a rubber band, and select the grid layout
              &#8212; resize the complete layout about three-quarters
              the height of the dialog.
            </P
></LI
><LI
><P
>Create a groupbox below the
              constellation of listboxes and edit controls, and put,
              roughly vertically, three radio buttons in it. 
            </P
></LI
><LI
><P
>Select the groupbox and click on
              the vertical layout manager button. Note that if you
              have the object browser open, you won't see this layout
              manager: the groupbox takes that function.
            </P
></LI
><LI
><P
>Create two checkboxes, next to
              each other, below the groupbox.
            </P
></LI
><LI
><P
>Select the listboxes, and select
              the horizontal layout manager.
            </P
></LI
><LI
><P
>Now select the form and then the
              grid layout manager.
            </P
></LI
></OL
><P
>The result should be quite pleasing
          &#8212; take a look at how Designer created the final grid
          layout. Perhaps it would be better to encase the checkboxes
          in a groupbox, too, but this is not essential. Some GUI
          design guidelines urge you to envelop everything but the
          <SPAN
CLASS="GUIBUTTON"
>OK</SPAN
> and <SPAN
CLASS="GUIBUTTON"
>Cancel</SPAN
>
          buttons (and perhaps the <SPAN
CLASS="GUIBUTTON"
>Help</SPAN
> button
          if its in the same row or column) in a frame with a title.
          Personally, I'm in favor of that recommendation, but in this
          you may follow the dictates of your heart (or of your
          primary platform).</P
><P
>Ultimately, the layout management offered by the
          Designer is useful and sufficient for most cases; in certain
          cases you might want to experiment with coding the layout
          management yourself. This is a lot more flexible, but it
          takes a lot more time, too.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>Generating and using Python code with pyuic</A
></H2
><P
>We have already converted a Designer
        design to Python code. This can be done using either
        BlackAdder, with the menu option <SPAN
CLASS="GUIMENUITEM"
>Compile
          Form</SPAN
> from the <SPAN
CLASS="GUIMENU"
>File</SPAN
> menu, or
        with a stand-alone utility, such as
        <TT
CLASS="FILENAME"
>pyuic</TT
>.</P
><P
>The stand-alone utility
        <B
CLASS="COMMAND"
>pyuic</B
> has an interesting option that is
        currently  not present in
        the BlackAdder IDE. Using the <TT
CLASS="PARAMETER"
><I
>-x</I
></TT
> parameter, a small stub is
        generated at the bottom of the file that enables you to run
        the generated code directly.</P
><P
>The resulting Python file has all the
        hallmarks of generated code. That is to say, it is a mess you
        won't want to edit by hand. Especially since it will be
        regenerated every time you change your form.
      </P
><P
>The right way to work with these
        generated files is to subclass them. If you have created a
        form, for example <TT
CLASS="FILENAME"
>frmcomplex.py</TT
>, that
        contains the generated class
        <TT
CLASS="CLASSNAME"
>FrmComplex</TT
>, then your next step is to
        create a new Python file, <TT
CLASS="FILENAME"
>dlgcomplex.py</TT
>,
        which contains the following class definition:</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 11-1. dlgcomplex.py &#8212; a subclass of frmcomplex.py</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#
# dglcomplex.py
#
import sys
from qt import *
from frmcomplex import FrmComplex                          <IMG
SRC="images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
>

class DlgComplex (FrmComplex):                             <IMG
SRC="images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
>
    def __init__(self, parent = None,name = None,modal = 0,fl = 0):
        FrmComplex.__init__(self, parent, name, fl)        <IMG
SRC="images/callouts/3.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(3)"></A
>

    def accept(self):                                      <IMG
SRC="images/callouts/4.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(4)"></A
>
        print "OK is pressed"
        FrmComplex.accept(self)                            <IMG
SRC="images/callouts/5.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(5)"></A
>

    def reject(self):
        print "Cancel pressed"
        QDialog.reject(self)                               <IMG
SRC="images/callouts/6.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(6)"></A
>

if __name__ == '__main__':                                 <IMG
SRC="images/callouts/7.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(7)"></A
>
    a = QApplication(sys.argv)
    QObject.connect(a,SIGNAL('lastWindowClosed()'),a,SLOT('quit()'))
    w = DlgComplex()                                       <IMG
SRC="images/callouts/8.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(8)"></A
>
    a.setMainWidget(w)
    w.show()
    a.exec_loop()
        </PRE
><DIV
CLASS="CALLOUTLIST"
><DL
COMPACT="COMPACT"
><DT
><A href="x4274.htm#IMPORT"><IMG
SRC="images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
></DT
><DD
>Importing the generated
                class</DD
><DT
><A href="x4274.htm#CLASSDEF"><IMG
SRC="images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
></DT
><DD
>This form is a subclass of the
                generated class</DD
><DT
><A href="x4274.htm#PARENTCALL"><IMG
SRC="images/callouts/3.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(3)"></A
></DT
><DD
>By passing
                <TT
CLASS="PARAMETER"
><I
>self</I
></TT
> to the parent class, all
                references in the parent class will be routed
                <SPAN
><I
CLASS="EMPHASIS"
>via</I
></SPAN
> the definitions in the
                subclass.</DD
><DT
><A href="x4274.htm#SUBACCEPT"><IMG
SRC="images/callouts/4.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(4)"></A
></DT
><DD
>Any slot of method of QDialog
                can be reimplemented in a subclass of QDialog. In this
                case, the <TT
CLASS="FUNCTION"
>accept()</TT
> and
                <TT
CLASS="FUNCTION"
>reject()</TT
> methods are
                re-implemented to add custom behavior to the OK and
                Cancel actions. Remember that we have already created
                the connections between the
                <TT
CLASS="FUNCTION"
>clicked()</TT
> signals of these
                buttons and these methods in the Designer.
              </DD
><DT
><A href="x4274.htm#CALLTOPARENTACCEPT"><IMG
SRC="images/callouts/5.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(5)"></A
></DT
><DD
>However, if you want to make use
                of the default functionality of the
                <TT
CLASS="CLASSNAME"
>QDialog</TT
> class, you must also
                call the implementation of the subclassed function in
                the parent class.
              </DD
><DT
><A href="x4274.htm#CALLTOQTDIALOG"><IMG
SRC="images/callouts/6.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(6)"></A
></DT
><DD
>Because the generated code in
                FrmComplex doesn't really add anything, calling
                <TT
CLASS="CLASSNAME"
>QDialog</TT
>.<TT
CLASS="FUNCTION"
>reject()</TT
> 
                works just as well.
              </DD
><DT
><A href="x4274.htm#STUB"><IMG
SRC="images/callouts/7.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(7)"></A
></DT
><DD
>This is a stub main to test the
                dialog.
              </DD
><DT
><A href="x4274.htm#CREATEDIALOG"><IMG
SRC="images/callouts/8.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(8)"></A
></DT
><DD
>Make sure you instantiate the
                right class: the <TT
CLASS="CLASSNAME"
>DlgComplex</TT
>,
                not the <TT
CLASS="CLASSNAME"
>frmComplex</TT
>! Cutting and
                pasting can lead to difficult-to-find bugs &#8212;I
                have all too often copied the stub from the parent
                file and forgot to change the classname...
              </DD
></DL
></DIV
></DIV
><P
>The next move is extending the constructor of
        the derived class to set the initial values of the various
        widgets.</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 11-2. Setting default values</B
></P
><PRE
CLASS="PROGRAMLISTING"
>    def __init__(self, parent = None,name = None,modal = 0,fl = 0):
        FrmComplex.__init__(self, parent, name, fl)

        self.ListBox2.insertItem("That's a turnip")
        self.ListBox2.insertItem("Further nonsense")

        self.RadioButton1.setChecked(1)
        </PRE
></DIV
><P
>As you can see, it's simply a matter of
        remembering what names you gave each widget, and inserting
        stuff &#8212; no rocket science here.</P
><P
>Accessing the values of each widget
        after the user has pressed <SPAN
CLASS="GUIBUTTON"
>OK</SPAN
> is just
        as easy. A dialog may disappear from screen when the user
        presses <SPAN
CLASS="GUIBUTTON"
>OK</SPAN
>, but that does not mean that
        the dialog has disappeared from memory. As long as there is a
        variable that points to the dialog, you can access each and
        every field.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>Generating C++ code with uic</A
></H2
><P
>Qt is originally a C++ toolkit &#8212;
        and if you acquire a license for Qt, be it the free, GPLed
        Unix/X11 version or the (non-)commercial Windows/Unix license,
        you can take the <TT
CLASS="FILENAME"
>.ui</TT
> files you have
        created with BlackAdder and compile them to C++ using the
        <B
CLASS="COMMAND"
>uic</B
> utility.</P
><P
>C++ is a bit more complicated than
        Python, and this is reflected in the more complex procedure
        you need to follow when converting a <TT
CLASS="FILENAME"
>.ui</TT
>
        to C++. First of all, you need to generate the
        <SPAN
><I
CLASS="EMPHASIS"
>header</I
></SPAN
> files with the <B
CLASS="COMMAND"
>uic -o
          dialog.h dialog.ui</B
> command. Next, you generate the
        actual C++ implementation with the <B
CLASS="COMMAND"
>uic -i dialog.h -o
          dialog.cpp dialog.ui</B
> command. The
        <TT
CLASS="OPTION"
>-i</TT
> tells <B
CLASS="COMMAND"
>uic</B
> to
        <SPAN
><I
CLASS="EMPHASIS"
>include</I
></SPAN
> the header file,
        <TT
CLASS="FILENAME"
>dialog.h</TT
>.</P
><P
>From that moment on, the work is the
        same as with Python. You subclass the generated code, adding
        real implementation logic. Clever usage will include using
        <B
CLASS="COMMAND"
>make</B
> to autogenerate the header and
        implementation files to ensure that the design of the forms in
        the compiled app always corresponds to the latest
        designs.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A accesskey="P" href="c4079.htm">Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="H" href="book1.htm">Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A accesskey="N" href="p4627.htm">Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Qt Designer, BlackAdder and uic</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="U" href="c4079.htm">Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Creating real applications with PyQt</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
      </td>
      </tr>
      </table>
      </td>
    </tr>
  </table>
  
    
