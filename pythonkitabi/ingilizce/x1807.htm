

  
  <table border="0" cellspacing="0" cellpadding="3" width="100%"><tr><td>
    <div align="center" id="bldcontent">
      <a href="http://www.opendocspublishing.com/"><img src="../images/opendocs.png" width="63" height="76" border="0"></a>
      <br>
      <div class="symbol">Your OpenSource Publisher&#153;</div>
    </div>
    
  </td></tr></table>
  
  <div align="center" class="author">
      	<a href="../products.lxp.html">Products</a>
	&nbsp;|&nbsp;
	<a href="../wheretobuy.lxp.html">Where to buy</a>
	&nbsp;|&nbsp;
	<a href="../bookstore.lxp.html">Retailers</a>
	&nbsp;|&nbsp;
	<a href="../FAQ.lxp.html">FAQ</a>
	&nbsp;|&nbsp;
        <a href="../writeforus.lxp.html">Write for Us.</a>
        &nbsp;|&nbsp;
        <a href="x1807.htm#contact">Contact Us.</a>
  </div>
    <table border="0" cellspacing="3" cellpadding="0" width="100%"><tr><td width="100%">
      <div class="content">
        <table border="0" cellspacing="2" cellpadding="0" width="100%"><tr><td width="100%">
          <div align="center">
<H4 CLASS="AUTHOR"><A NAME="AEN5">Boudewijn Rempt</A>
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
<img src="ODPyQT125.png">
</a>
<br>
ISBN: 0-97003300-4-4
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
Available from bookstores everywhere or you can order it here.
</a>
<p>
You can download the source files for the book <a href="pyqtsrc.tgz">(code / eps) here.</a>
<hr>
</div>

          
          <HTML
><HEAD
><TITLE
>A parser-formatter using signals and slots</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.72
"><LINK
REL="HOME"
TITLE="GUI Programming with Python: QT Edition"
HREF="book1.htm"><LINK
REL="UP"
TITLE="Signals and Slots in Depth"
HREF="c1267.htm"><LINK
REL="PREVIOUS"
TITLE="Disconnecting"
HREF="x1631.htm"><LINK
REL="NEXT"
TITLE="Conclusion"
HREF="x2026.htm"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GUI Programming with Python: QT Edition</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A accesskey="P" href="x1631.htm">Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 7. Signals and Slots in Depth</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A accesskey="N" href="x2026.htm">Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
>A parser-formatter using signals and slots</A
></H1
><P
>The use of signals and slots in the
      previous section was an example of using signals and slots in
      GUI building. Of course, you can use signals and slots to link
      GUI widgets with each other, and most of your slot
      implementations will be in subclasses of
      <TT
CLASS="CLASSNAME"
>QWidget</TT
> &#8212; but the mechanism works
      well under other circumstances. A GUI is not necessary.</P
><P
>In this section, I will show how signals
      and slots make a natural extension to the event driven nature of
      XML parsers. As you probably know, XML is a fairly simple
      mark-up language that can be used to represent hierarchical
      data. There are basically two ways to look at XML data. One is
      to convert the data in one fell swoop into some hierarchical
      representation (for example, dictionaries containing
      dictionaries). This method is the DOM (data-object-model)
      representation. Alternatively, you can parse the data character
      by character, generating an event every time a certain chunk has
      been completed; this is the SAX parser model.</P
><P
>Python contains support for both XML
      handling models in its standard libraries. The currently
      appreciated module is xml.sax, which can make use of the fast
      expat parser. However, expat is not part of standard Python.
      There is an older, deprecated module, xmllib, which uses regular
      expressions for parsing. While deprecated, this module is still
      the most convenient introduction to XML handling with Python.
      It's also far more &#8216;Pythonic' in feel than the Sax module,
      which is based on the way Java does things.
    </P
><P
>We'll create a special module that will use
      xmllib to parse an XML document and generate PyQt signals for
      all elements of that document. It is easy to connect these
      signals to another object (for instance, a PyQt
      <TT
CLASS="CLASSNAME"
>QListView</TT
> which can show the XML document
      in a treeview). But it would be just as easy to create a
      formatter object that would present the data as HTML. A slightly
      more complicated task would be to create a formatter object that
      would apply XSLT transformations to the XML document &#8212;
      that is, it would format the XML using stylesheets. Using
      signals and slots, you can connect more than one transformation
      to the same run of the parser. A good example would be a
      combination of a GUI interface, a validator, and a statistics
      calculator.</P
><P
>The next example is very simple. It is easy to extend,
    though, with special nodes for comments, a warning message
    box for errors, and more columns for attributes.</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 7-9. An XML parser with signals and slots</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#
# qtparser.py &#8212; a simple parser that, using xmllib,
# generates a signal for every parsed XML document.
#

import sys
import xmllib                                              <IMG
SRC="images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
>
from qt import *

TRUE=1                                                     <IMG
SRC="images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
>
FALSE=0
        </PRE
><DIV
CLASS="CALLOUTLIST"
><DL
COMPACT="COMPACT"
><DT
><A href="x1807.htm#XMLLIB"><IMG
SRC="images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
></DT
><DD
>We import the deprecated
              xmllib module. It is deprecated because the sax module,
              which uses the expat library, is a lot faster.
              The xmllib module is far easier to use, however, and since it
              uses regular expressions for its parsing, it is
              available everywhere, while the expat library must be
              compiled separately.</DD
><DT
><A href="x1807.htm#TRUE"><IMG
SRC="images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
></DT
><DD
>It is often convenient to
          define constants for the boolean values true and false.</DD
></DL
></DIV
><PRE
CLASS="PROGRAMLISTING"
>class Parser(xmllib.XMLParser):                            <IMG
SRC="images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
>

    def __init__(self, qObject,  *args):                   <IMG
SRC="images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
>
        xmllib.XMLParser.__init__(self)
        self.qObject=qObject

    def start(self, document):                             <IMG
SRC="images/callouts/3.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(3)"></A
>
        xmllib.XMLParser.feed(self, document)
        xmllib.XMLParser.close(self)

        </PRE
><DIV
CLASS="CALLOUTLIST"
><DL
COMPACT="COMPACT"
><DT
><A href="x1807.htm#CLASS"><IMG
SRC="images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
></DT
><DD
>This is the <TT
CLASS="CLASSNAME"
>Parser</TT
> class. It
              inherits the <TT
CLASS="CLASSNAME"
>XMLParser</TT
> class from
              the xmllib module. The <TT
CLASS="CLASSNAME"
>XMLParser</TT
>
              class can be used in two ways: by overriding a set of
              special methods that are called when the parser
              encounters a certain kind of XML element, or by
              overriding a variable, <TT
CLASS="VARNAME"
>self.elements</TT
>,
              which refers to a dictionary of tag-to-method mappings.
              Overriding <TT
CLASS="VARNAME"
>self.elements</TT
> is very
              helpful if you are writing a parser for a certain DTD or
              XML document type definition, though it is not the way
              to go for a generic XML structure viewer (such as the
              one we are making now).</DD
><DD
><P
>An example for a Designer ui file could contain the
          following definition:</P
></DD
><PRE
CLASS="PROGRAMLISTING"
>self.elements={'widget'  : (self.start_widget,
                            self.end_widget)
              ,'class'   : (self.start_class,
                            self.end_class)
              ,'property': (self.start_property,
                            self.end_property)
              ,name'     : (self.start_name,
                            self.end_name)}
          </PRE
><DD
><P
>The keys to this dictionary are the actual tag
              strings. The tuple that follows the key consists of the
              functions that should be called for the opening and the
              ending tag. If you don't want a function to be called,
              enter None. Of course, you must implement these
              functions yourself, in the derived parser class.</P
></DD
><DT
><A href="x1807.htm#CONSTRUCTOR"><IMG
SRC="images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
></DT
><DD
>The first argument (after self, of course) to the
              constructor is a QObject. Multiple inheritance isn't a
              problem in Python, generally speaking, but you cannot
              multiply inherit from PyQt classes. Sip gets hopelessly
              confused if you do so. So we pass a
              <TT
CLASS="CLASSNAME"
>QObject</TT
> to the constructor of the
              <TT
CLASS="CLASSNAME"
>Parser</TT
> class. Later, we will have
              this <TT
CLASS="CLASSNAME"
>QObject</TT
> object emit the
              necessary signals.</DD
><DT
><A href="x1807.htm#START"><IMG
SRC="images/callouts/3.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(3)"></A
></DT
><DD
>The <TT
CLASS="FUNCTION"
>start</TT
>
            function takes a string as its parameter. This string
            should contain the entire XML document. It is
            also possible to rewrite this function to read a file line by
            line; the default approach makes it difficult to work with
            really large XML files. Reading a file line by line is a
            lot easier on your computer's memory. You should call
            <TT
CLASS="FUNCTION"
>close()</TT
> after the last bit of text
            has been passed to the parser.</DD
></DL
></DIV
><PRE
CLASS="PROGRAMLISTING"
>    #
    # Data handling functions                              <IMG
SRC="images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
>
    #
    def handle_xml(self, encoding, standalone):            <IMG
SRC="images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
>
        self.qObject.emit(PYSIGNAL("sigXML"),
                          (encoding, standalone))
                                                           <IMG
SRC="images/callouts/3.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(3)"></A
>
    def handle_doctype(self, tag, pubid, syslit, data):
        self.qObject.emit(PYSIGNAL("sigDocType"),
                         (tag, pubid, syslit, data,))      <IMG
SRC="images/callouts/4.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(4)"></A
>

    def handle_data(self, data):
        self.qObject.emit(PYSIGNAL("sigData"),(data,))     <IMG
SRC="images/callouts/5.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(5)"></A
>

    def handle_charref(self, ref):
        self.qObject.emit(PYSIGNAL("sigCharref"),(ref,))   <IMG
SRC="images/callouts/6.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(6)"></A
>

    def handle_comment(self, comment):
        self.qObject.emit(PYSIGNAL("sigComment"),(comment,))<IMG
SRC="images/callouts/7.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(7)"></A
>

    def handle_cdata(self, data):
        self.qObject.emit(PYSIGNAL("sigCData"),(data,))    <IMG
SRC="images/callouts/8.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(8)"></A
>

    def handle_proc(self, data):
        self.qObject.emit(PYSIGNAL("sigProcessingInstruction"),<IMG
SRC="images/callouts/9.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(9)"></A
>
                         (data,))

    def handle_special(self, data):                        <IMG
SRC="images/callouts/10.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(10)"></A
>
        self.qObject.emit(PYSIGNAL("sigSpecial"), (data,))

    def syntax_error(self, message):                       <B
>(11)</B
></A
>
        self.qObject.emit(PYSIGNAL("sigError"),(message,))

    def unknown_starttag(self, tag, attributes):           <B
>(12)</B
></A
>
        self.qObject.emit(PYSIGNAL("sigStartTag"),
                         (tag,attributes))
                                                           <B
>(13)</B
></A
>
    def unknown_endtag(self, tag):
        self.qObject.emit(PYSIGNAL("sigEndTag"),(tag,))
                                                           <B
>(14)</B
></A
>
    def unknown_charref(self, ref):
        self.qObject.emit(PYSIGNAL("sigCharRef"),(ref,))

    def unknown_entityref(self, ref):
        self.qObject.emit(PYSIGNAL("sigEntityRef"),(ref,))
        </PRE
><DIV
CLASS="CALLOUTLIST"
><DL
COMPACT="COMPACT"
><DT
><A href="x1807.htm#DATA-HANDLING"><IMG
SRC="images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
></DT
><DD
>The
              xmllib.<TT
CLASS="CLASSNAME"
>XMLParser</TT
> class defines a
              number of methods that should be overridden if you want
              special behavior. Even though we will only use the
              methods that are called when a document is started and
              when a simple element is opened and closed, I've
              implemented all possible functions here.</DD
><DT
><A href="x1807.htm#DH1"><IMG
SRC="images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
></DT
><DD
>Every valid XML document should
              start with a magic text that declares itself to be XML
              &#8212; note that that the .ui Designer files don't
              comply with this requirement. This method is fired (and
              thus the signal is fired) when the parser encounters
              this declaration. Normally, it looks like this:
              <TT
CLASS="LITERAL"
>&#60;?xml version="1.0"
                standalone="no"?&#62;</TT
>, with the minor
              variation that standalone can also have the value "yes".
          </DD
><DT
><A href="x1807.htm#DH2"><IMG
SRC="images/callouts/3.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(3)"></A
></DT
><DD
>If an XML document has a
              documenttype, this method is called. A doctype
              declaration looks like this:</DD
><PRE
CLASS="SCREEN"
>&#60;!DOCTYPE book PUBLIC "-//Norman Walsh//DTD DocBk XML V3.1.4//EN"
     "http://nwalsh.com/docbook/xml/3.1.4/db3xml.dtd"&#62;
            </PRE
><DD
><P
>and points to a DTD &#8212; a
              description of what's allowed in this particular kind of
              XML document.
          </P
></DD
><DT
><A href="x1807.htm#DH3"><IMG
SRC="images/callouts/4.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(4)"></A
></DT
><DD
>There can be data in between the tags in an XML document,
            just as with the text in a HTML document. This function is
            called when the parser encounters such data.</DD
><DT
><A href="x1807.htm#DH4"><IMG
SRC="images/callouts/5.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(5)"></A
></DT
><DD
>In XML, you can use special
              characters that are entered with  &#38;#, a number, and
              closed with a semicolon. Python's xmllib will want to
              translate this to an ASCII character. You cannot use
              xmllib to parse documents that contain references to
              Unicode characters.</DD
><DT
><A href="x1807.htm#DH5"><IMG
SRC="images/callouts/6.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(6)"></A
></DT
><DD
>XML has the same kind of comments as HTML. Most
          parsers simply pass the comments, but if you want to show
          them (for instance, in a structured view of an XML document)
          or if you want to preserve the contents of the file exactly,
          you can connect a slot to the signal emitted by this function.
          </DD
><DT
><A href="x1807.htm#DH6"><IMG
SRC="images/callouts/7.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(7)"></A
></DT
><DD
>CDATA is literal data enclosed
              between <TT
CLASS="LITERAL"
>&#60;![CDATA[</TT
> and
              <TT
CLASS="LITERAL"
>]]&#62;</TT
>. A file containing </DD
><PRE
CLASS="SCREEN"
>&#60;![CDATA[surely you will be allowed to
starve to death in one of the royal parks.]]&#62;
            </PRE
><DD
><P
>will present the quote
              &#8216;surely you will be allowed to starve to death in
              one of the royal parks.' to any slot that is connected
              to <TT
CLASS="FUNCTION"
>sigCData</TT
>.</P
></DD
><DT
><A href="x1807.htm#DH7"><IMG
SRC="images/callouts/8.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(8)"></A
></DT
><DD
>This is called when the XML document
              contains processing instructions. A processing
              instruction begins with &#60;?. All special cases, such
              as the XML declaration itself, are handled by other
              methods.
          </DD
><DT
><A href="x1807.htm#DH8"><IMG
SRC="images/callouts/9.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(9)"></A
></DT
><DD
>You can declare entities in XML
              &#8212; references to something externally defined.
              Those start with &#60;!. The contents of the declaration
              will be passed on in the <TT
CLASS="VARNAME"
>data</TT
>
              argument.

          </DD
><DT
><A href="x1807.htm#DH9"><IMG
SRC="images/callouts/10.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(10)"></A
></DT
><DD
>XML is far less forgiving than HTML
              (or at least, XML has both a stricter definition and
              less easy-going parsers), and whenever an error is
              encountered, such as forgetting to close a tag, this
              method is called.
          </DD
><DT
><A href="x1807.htm#DH10"><B
>(11)</B
></A
></DT
><DD
>              <TT
CLASS="FUNCTION"
>unknown_starttag</TT
> is the most
              interesting method in the
              <TT
CLASS="CLASSNAME"
>xmllib.XMLParser</TT
> class. This is
              called whenever the xmllib parser encounters a plain tag
              that is not present in its <TT
CLASS="VARNAME"
>elements</TT
>
              dictionary. That is, it will be called for all elements
              in our current implementation.</DD
><DT
><A href="x1807.htm#DH11"><B
>(12)</B
></A
></DT
><DD
>Likewise,
              <TT
CLASS="FUNCTION"
>unknown_endtag</TT
> is called for the
              corresponding ending tags.
          </DD
><DT
><A href="x1807.htm#DH12"><B
>(13)</B
></A
></DT
><DD
>Whenever the parser encounters an unresolvable numeric
          character reference, this function is called.
          </DD
><DT
><A href="x1807.htm#DH13"><B
>(14)</B
></A
></DT
><DD
>Unknown entities are forbidden in
              XML &#8212; if you use an entity somewhere in your
              document (which you can do by placing the name of the
              entity between an ampersand and a semicolon), then it
              must be declared. However, you might want to catch
              occurrences of unknown entities and do something
              special. That's why the function
              <TT
CLASS="FUNCTION"
>unknown_entityref</TT
> is implemented
              here. By default <TT
CLASS="FUNCTION"
>unknown_entityref</TT
>
              calls the <TT
CLASS="FUNCTION"
>syntax_error()</TT
> function
              of <TT
CLASS="CLASSNAME"
>xmllib.XMLParser</TT
>.
          </DD
></DL
></DIV
><P
>The <TT
CLASS="CLASSNAME"
>TreeView</TT
> class will show the
        contents of the XML file.</P
><PRE
CLASS="PROGRAMLISTING"
>class TreeView(QListView):                                 <IMG
SRC="images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
>

    def __init__(self, *args):
        apply(QListView.__init__,(self, ) + args)
        self.stack=[]                                      <IMG
SRC="images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
>
        self.setRootIsDecorated(TRUE)                      <IMG
SRC="images/callouts/3.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(3)"></A
>
        self.addColumn("Element")                          <IMG
SRC="images/callouts/4.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(4)"></A
>

    def startDocument(self, tag, pubid, syslit, data):     <IMG
SRC="images/callouts/5.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(5)"></A
>
        i=QListViewItem(self)
        if tag == None: tag = "None"
        i.setText(0, tag)
        self.stack.append(i)

    def startElement(self, tag, attributes):               <IMG
SRC="images/callouts/6.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(6)"></A
>
        if tag == None: tag = "None"
        i=QListViewItem(self.stack[-1])
        i.setText(0, tag)
        self.stack.append(i)

    def endElement(self, tag):                             <IMG
SRC="images/callouts/7.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(7)"></A
>
        del(self.stack[-1])
      </PRE
><DIV
CLASS="CALLOUTLIST"
><DL
COMPACT="COMPACT"
><DT
><A href="x1807.htm#TVCLASS"><IMG
SRC="images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
></DT
><DD
>The <TT
CLASS="CLASSNAME"
>TreeView</TT
>
              class is a simple subclass of PyQt's versatile
              <TT
CLASS="CLASSNAME"
>QListView</TT
> class.</DD
><DT
><A href="x1807.htm#TVSTACK"><IMG
SRC="images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
></DT
><DD
>Because XML is a hierarchical file
              format, elements are neatly nested in each other. In
              order to be able to create the right treeview, we should
              keep a stack of the current element depth. The last
              element of the stack will be the parent element of all
              new elements.</DD
><DT
><A href="x1807.htm#TVDECORATION"><IMG
SRC="images/callouts/3.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(3)"></A
></DT
><DD
>This option sets the beginning of
              the tree at the first element, making it clear to the
              user that it's an expandable tree instead of a simple
              list.</DD
><DT
><A href="x1807.htm#TVCOLS"><IMG
SRC="images/callouts/4.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(4)"></A
></DT
><DD
>We present only one column in the
              listview &#8212; if you want to show the attributes of
              elements, too, you might add a few more columns.</DD
><DT
><A href="x1807.htm#TVF1"><IMG
SRC="images/callouts/5.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(5)"></A
></DT
><DD
>The
              <TT
CLASS="FUNCTION"
>startDocument</TT
> function is called
              when the XML document is opened. It also starts the call
              stack by creating the first element. The first
              <TT
CLASS="CLASSNAME"
>QListViewItem</TT
> object has the
              listview as a parent; all others with have a
              <TT
CLASS="CLASSNAME"
>QListViewItem</TT
> object as parent.
              The constructor of <TT
CLASS="CLASSNAME"
>QListViewItem</TT
>
              is so overloaded that sip tends to get confused, so I
              create the item and set its text separately.</DD
><DT
><A href="x1807.htm#TVF2"><IMG
SRC="images/callouts/6.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(6)"></A
></DT
><DD
>Whenever an element is opened, a
          <TT
CLASS="CLASSNAME"
>QListViewItem</TT
> item is created and
          pushed on the stack, where it becomes the parent for newly
          opened elements.</DD
><DT
><A href="x1807.htm#TVF3"><IMG
SRC="images/callouts/7.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(7)"></A
></DT
><DD
>Conversely, when the element is
              closed, it is popped <SPAN
><I
CLASS="EMPHASIS"
>from</I
></SPAN
> the
              stack.</DD
></DL
></DIV
><PRE
CLASS="PROGRAMLISTING"
>def main(args):

    if (len(args) == 2):
        app = QApplication(sys.argv)

        QObject.connect(app, SIGNAL('lastWindowClosed()'),
                        app, SLOT('quit()'))
        w = TreeView()
        app.setMainWidget(w)

        o=QObject()                                        <IMG
SRC="images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
>
        p=Parser(o)                                        <IMG
SRC="images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
>
        QObject.connect(o, PYSIGNAL("sigDocType"),         <IMG
SRC="images/callouts/3.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(3)"></A
>
                           w.startDocument)
        QObject.connect(o, PYSIGNAL("sigStartTag"),
                           w.startElement)
        QObject.connect(o, PYSIGNAL("sigEndTag"),
                           w.endElement)

        s=open(args[1]).read()                             <IMG
SRC="images/callouts/4.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(4)"></A
>
        p.start(s)

        w.show()
        app.exec_loop()
    else:
        print "Usage: python qtparser.py FILE.xml"

if __name__=="__main__":
    main(sys.argv)
        </PRE
><DIV
CLASS="CALLOUTLIST"
><DL
COMPACT="COMPACT"
><DT
><A href="x1807.htm#QOBJECT"><IMG
SRC="images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
></DT
><DD
>Here we create a
              <TT
CLASS="CLASSNAME"
>QObject</TT
> which is used to emit all
              necessary signals, since we cannot inherit from more
              than one PyQt class at the same time. Note that by using
              this technique, you don't have to subclass from
              <TT
CLASS="CLASSNAME"
>QObject</TT
> in order to be able to
              emit signals. Sometimes delegation works just as
              well.</DD
><DT
><A href="x1807.htm#PARSER"><IMG
SRC="images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
></DT
><DD
>A parser object is created, with the
              <TT
CLASS="CLASSNAME"
>QObject</TT
> object as its argument.</DD
><DT
><A href="x1807.htm#CONNECTIONS"><IMG
SRC="images/callouts/3.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(3)"></A
></DT
><DD
>Before feeding the parser the text, all connections
              we want are made from the <TT
CLASS="CLASSNAME"
>QObject</TT
>
              object (which we passed to the parser to make sure it
              can emit signals) to the <TT
CLASS="CLASSNAME"
>TreeView</TT
>
              object that forms the main window.</DD
><DT
><A href="x1807.htm#READING"><IMG
SRC="images/callouts/4.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(4)"></A
></DT
><DD
>The file whose name was given on the command
              line is read and passed on to the parser. I have included
              a very small test file, <TT
CLASS="FILENAME"
>test.xml</TT
>,
              but you can use any Designer UI design file.</DD
></DL
></DIV
></DIV
><P
>This is a very simple and convenient way
      of working with XML files and PyQt gui's &#8212; but it's
      generally useful, too. The standard way of working with XML
      files and parsers allows for only one function to be called for
      each tag. Using signals and slots, you can have as many slots
      connected to each signal as you want. For instance, you can have
      not only a gui, but also an analyzer that produces statistics
      listening in on the same parsing run.</P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>The result of parsing a Designer .ui file.</P
></DIV
></P
></DIV
><P
>On a final note, there is one bug in this
      code... See if you can find it, or consult
     <A href="x3270.htm#CH2LISTVIEW">the Section called <I
>QListView and QListViewItem</I
> in Chapter 10</A
> for an explanation.</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A accesskey="P" href="x1631.htm">Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="H" href="book1.htm">Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A accesskey="N" href="x2026.htm">Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Disconnecting</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="U" href="c1267.htm">Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Conclusion</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
      </td>
      </tr>
      </table>
      </td>
    </tr>
  </table>
  
    
