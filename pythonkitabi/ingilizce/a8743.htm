

  
  <table border="0" cellspacing="0" cellpadding="3" width="100%"><tr><td>
    <div align="center" id="bldcontent">
      <a href="http://www.opendocspublishing.com/"><img src="../images/opendocs.png" width="63" height="76" border="0"></a>
      <br>
      <div class="symbol">Your OpenSource Publisher&#153;</div>
    </div>
    
  </td></tr></table>
  
  <div align="center" class="author">
      	<a href="../products.lxp.html">Products</a>
	&nbsp;|&nbsp;
	<a href="../wheretobuy.lxp.html">Where to buy</a>
	&nbsp;|&nbsp;
	<a href="../bookstore.lxp.html">Retailers</a>
	&nbsp;|&nbsp;
	<a href="../FAQ.lxp.html">FAQ</a>
	&nbsp;|&nbsp;
        <a href="../writeforus.lxp.html">Write for Us.</a>
        &nbsp;|&nbsp;
        <a href="a8743.htm#contact">Contact Us.</a>
  </div>
    <table border="0" cellspacing="3" cellpadding="0" width="100%"><tr><td width="100%">
      <div class="content">
        <table border="0" cellspacing="2" cellpadding="0" width="100%"><tr><td width="100%">
          <div align="center">
<H4 CLASS="AUTHOR"><A NAME="AEN5">Boudewijn Rempt</A>
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
<img src="ODPyQT125.png">
</a>
<br>
ISBN: 0-97003300-4-4
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
Available from bookstores everywhere or you can order it here.
</a>
<p>
You can download the source files for the book <a href="pyqtsrc.tgz">(code / eps) here.</a>
<hr>
</div>

          
          <HTML
><HEAD
><TITLE
>PyQwt: Python Bindings for Qwt</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.72
"><LINK
REL="HOME"
TITLE="GUI Programming with Python: QT Edition"
HREF="book1.htm"><LINK
REL="UP"
TITLE="Appendices"
HREF="p8645.htm"><LINK
REL="PREVIOUS"
TITLE="Reading the Qt Documentation"
HREF="a8647.htm"><LINK
REL="NEXT"
TITLE="PyQwt"
HREF="x8818.htm"></HEAD
><BODY
CLASS="APPENDIX"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GUI Programming with Python: QT Edition</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A accesskey="P" href="a8647.htm">Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A accesskey="N" href="x8818.htm">Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="APPENDIX"
><H1
>Appendix B. PyQwt: Python Bindings for Qwt</A
></H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A href="a8743.htm#SECTNUMPY">NumPy</A
></DT
><DT
><A href="x8818.htm">PyQwt</A
></DT
></DL
></DIV
><FONT
COLOR="RED"
>    Gerard Vermeulen
  </FONT
><P
>Using sip, it is possible to wrap any C++ library. Jim
    Bublitz, for instance, has wrapped the core libraries of KDE 2,
    and Gerard Vermeulen has wrapped the Qwt toolkit. This appendix
    has been written by Gerard Vermeulen to introduce this extension
    library.</P
><P
>PyQwt is a set of Python bindings for the Qt
    Widgets for Technics toolkit, which is freely downloadable at
    http://qwt.sourceforge.net. PyQwt is equally free, and available
    from http://gerard.vermeulen.free.fr.</P
><P
>Behind the innocuous trigram
    'Qwt' a complex set of widgets is hiding. This extension library,
    written by Josef Wilgen with the aid of many others, fills in a
    noticeable gap in the Qt library: data visualisation. This toolkit
    features fast plotting of 
    <TT
CLASS="LITERAL"
>Numerical Python arrays</TT
> (and Python lists or
    tuples) of Python floats.</P
><P
>Remember how we created a rolling chart in
    <A href="c7391.htm">Chapter 21</A
> when we investigated
    <TT
CLASS="CLASSNAME"
>QPainter</TT
>s? It was quite an interesting job,
    but for serious applications you'd need a stronger package.</P
><P
>Fortunately, Python possesses a very strong
    array manipulation package: the Numerical Python Extensions (or,
    affectionately, <SPAN
CLASS="APPLICATION"
>numpy</SPAN
>, available at
    http://www.pfdubois.com/numpy), which, when paired with the Qwt
    extensions, gives you the power to create complex graphing and
    charting applications.</P
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
>NumPy</A
></H1
><P
>The Numerical Python Extensions, also called
      NumPy or Numeric, turn Python into an ideal tool for
      experimental numerical and scientific computing (better than
      specialized programs like MatLab, Octave, RLab or SciLab). NumPy
      is useful for everybody who analyzes data with the help of a
      spreadsheet program like Microsoft Excel&#8212;it is not just
      for mathematicians and scientists who crunch lots of
      data.</P
><P
>NumPy defines a new data type, <TT
CLASS="LITERAL"
>NumPy
        array</TT
>, and a very complete set of operators and
      functions to manipulate <TT
CLASS="LITERAL"
>NumPy arrays</TT
>. All the
      functionality of NumPy can be obtained in pure Python, but NumPy
      gives you speed and elegance.</P
><P
>In the following, I assume that
      you have installed NumPy on your system. Doing so is not really
      difficult. There are binary packages for Windows, or source
      packages for all platforms. A source package is installed using
      distutils (see <A href="c8349.htm">Chapter 26</A
>), by typing</P
><PRE
CLASS="SCREEN"
>root@calcifer:/home/boud# python setup_all.py install
    </PRE
><P
>Once numpy is installed, you can start
      Python (or open the Interpreter window in BlackAdder) and import
      the NumPy extension:</P
><PRE
CLASS="PROGRAMLISTING"
>[packer@slow packer]$ python
Python 2.1.1 (#1, Aug 20 2001, 08:17:33) 
[GCC 2.95.3 19991030 (prerelease)] on linux2
Type "copyright", "credits" or "license" for more information.
&#62;&#62;&#62; from Numeric import *
&#62;&#62;&#62;
    </PRE
><P
>A <TT
CLASS="LITERAL"
>NumPy array</TT
> looks like
      a list and can be created from a list (in fact, from any
      sequency type: list, tuple or string).</P
><P
>Let's create and print a 1-dimensional
      <TT
CLASS="LITERAL"
>NumPy array</TT
> of Python floats:</P
><PRE
CLASS="PROGRAMLISTING"
>&#62;&#62;&#62; a = array([1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0, 81.0, 100.0])
&#62;&#62;&#62; print a
[   1.    4.    9.   16.   25.   36.   49.   64.   81.  100.]
&#62;&#62;&#62;
    </PRE
><P
>This creates a 1-dimensional <TT
CLASS="LITERAL"
>NumPy
        array</TT
>. All elements in the list should have the same
      data type.</P
><P
>A 2-dimensional <TT
CLASS="LITERAL"
>NumPy array</TT
> is created
      from a list of sub-lists: </P
><PRE
CLASS="PROGRAMLISTING"
>&#62;&#62;&#62; b = array([[0.0, 1.0], [2.0, 3.0]])
&#62;&#62;&#62; print b
[[ 0.  1.]
 [ 2.  3.]]
&#62;&#62;&#62;
    </PRE
><P
>The sub-lists should have the same length,
      and all the elements in all the sub-lists should have the same
      data type.</P
><P
>You can show off with
      <TT
CLASS="LITERAL"
>NumPy array</TT
>s of even higher dimensions (up to
      40, by default). For example, a 3-dimensional <TT
CLASS="LITERAL"
>NumPy
        array</TT
> is created from a list of sub-lists of
      sub-sub-lists:</P
><PRE
CLASS="PROGRAMLISTING"
>&#62;&#62;&#62; c = array([[[0.0, 1.0], [2.0, 3.0]], [[4.0, 5.0], [6.0, 7.0]]])
&#62;&#62;&#62; print c
[[[ 0.  1.]
  [ 2.  3.]]
 [[ 4.  5.]
  [ 6.  7.]]]
&#62;&#62;&#62;
    </PRE
><P
>The sub-lists should have the same length, the sub-sub-lists
      should have the same length, and all elements of all sub-sub-lists
      should have the same data type.</P
><P
>In the following, I am going to compare the functionality of
      <TT
CLASS="LITERAL"
>NumPy arrays</TT
> and lists. Here is an easier
      method to create a <TT
CLASS="LITERAL"
>NumPy array</TT
>:</P
><PRE
CLASS="PROGRAMLISTING"
>&#62;&#62;&#62; ax = arange(0.0, 5.0, 0.5)
&#62;&#62;&#62; print ax
[ 0.   0.5  1.   1.5  2.   2.5  3.   3.5  4.   4.5]
&#62;&#62;&#62;
    </PRE
><P
>The function call <TT
CLASS="FUNCTION"
>arange(0.0, 5.0, 0.5)</TT
>
      returns an array with elements ranging from 0.0 to 5.0
      (non-inclusive) in steps of 0.5. Here is a similiar function to
      return a list with the same properties: </P
><PRE
CLASS="PROGRAMLISTING"
>def lrange(start, stop, step):
    start, stop, step = float(start), float(stop), float(step)
    size = int(round((stop-start)/step))
    result = [start] * size
    for i in xrange(size):
        result[i] += i * step
    return result
    </PRE
><P
>After copying and pasting the function definition in your
      Python interpreter, do:</P
><PRE
CLASS="PROGRAMLISTING"
>&#62;&#62;&#62; lx = lrange(0.0, 5.0, 0.5)
&#62;&#62;&#62; print lx
[0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5]
    </PRE
><P
>Why are <TT
CLASS="LITERAL"
>NumPy arrays</TT
> better than lists?
      The full answer is speed and elegance. To compare lists and
      <TT
CLASS="LITERAL"
>NumPy arrays</TT
> with respect to elegance, lets
      use a simple function:</P
><PRE
CLASS="PROGRAMLISTING"
>def lorentzian(x):
    return 1.0/(1.0+(x-2.5)**2)
    </PRE
><P
>To calculate a list, ly, containing the function values for
    each element of ly, we can do:</P
><PRE
CLASS="PROGRAMLISTING"
>&#62;&#62;&#62; ly = [0.0]*len(lx)
&#62;&#62;&#62; for i in range(len(lx)): ly[i] = lorentzian(lx[i])
...
    </PRE
><P
>Do you know that you can get rid of the loop? The following is
      more elegant and slightly faster:</P
><PRE
CLASS="PROGRAMLISTING"
>&#62;&#62;&#62; ly = map(lorentzian, lx)
    </PRE
><P
><TT
CLASS="LITERAL"
>NumPy arrays</TT
> are even more elegant, and they
      allow:</P
><PRE
CLASS="PROGRAMLISTING"
>&#62;&#62;&#62; ay = lorentzian(ax)
    </PRE
><P
>Almost magic, isn't it? I wrote the function lorentzian(x)
      assuming that x is Python float. If you call lorentzian with a
      <TT
CLASS="LITERAL"
>NumPy array</TT
> as argument, it returns a
      <TT
CLASS="LITERAL"
>NumPy array</TT
>. This does not work with
      lists:</P
><PRE
CLASS="PROGRAMLISTING"
>&#62;&#62;&#62; ly = lorentzian(lx)
Traceback (most recent call last):
  File "&#60;stdin&#62;", line 1, in ?
  File "&#60;stdin&#62;", line 2, in lorentzian
TypeError: unsupported operand type(s) for -
&#62;&#62;&#62;
    </PRE
><P
>To compare speed, we create a list, xl, and a <TT
CLASS="LITERAL"
>NumPy
        array</TT
>, xa, with 100000 elements and use the profile
      module to time the statements <TT
CLASS="LITERAL"
>yl = map(lorentzian,
        xl)</TT
> and <TT
CLASS="LITERAL"
>ya =
        lorentzian(xa)</TT
>:</P
><PRE
CLASS="PROGRAMLISTING"
>&#62;&#62;&#62; import profile
&#62;&#62;&#62; xl = lrange(0, 10, 0.0001)
&#62;&#62;&#62; xa = arange(0, 10, 0.0001)
&#62;&#62;&#62; profile.run('yl = map(lorentzian, xl)')
         100002 function calls in 2.200 CPU seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   100000    1.000    0.000    1.000    0.000 &#60;stdin&#62;:1(lorentzian)
        1    1.200    1.200    2.200    2.200 &#60;string&#62;:1(?)
        0    0.000             0.000          profile:0(profiler)
        1    0.000    0.000    2.200    2.200 profile:0(yl = map(lorentzian, xl))


&#62;&#62;&#62; profile.run('ya = lorentzian(xa)')
         3 function calls in 0.090 CPU seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.090    0.090    0.090    0.090 &#60;stdin&#62;:1(lorentzian)
        1    0.000    0.000    0.090    0.090 &#60;string&#62;:1(?)
        0    0.000             0.000          profile:0(profiler)
        1    0.000    0.000    0.090    0.090 profile:0(ya = lorentzian(xa))


&#62;&#62;&#62;
    </PRE
><P
>On my computer, the Numerical Python extensions are almost
      25 times faster than pure Python!</P
><P
>There exists a scientific plotting program,
      <SPAN
CLASS="APPLICATION"
>SciGraphica</SPAN
>
      (http://scigraphica.sourceforge.net), which allows you to
      manipulate your data in a spreadsheet. The underlying engine is
      a python interpreter with the NumPy. Each column in the
      spreadsheet is in reality a <TT
CLASS="LITERAL"
>NumPy array</TT
>. This
      clearly demostrates the power of this extension. If you want to
      know more about NumPy, you can consult the excellent
      documentation at http://www.pfdubois.com/numpy, the homepage of
      NumPy.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A accesskey="P" href="a8647.htm">Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="H" href="book1.htm">Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A accesskey="N" href="x8818.htm">Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Reading the Qt Documentation</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="U" href="p8645.htm">Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>PyQwt</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
      </td>
      </tr>
      </table>
      </td>
    </tr>
  </table>
  
    
