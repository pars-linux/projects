

  
  <table border="0" cellspacing="0" cellpadding="3" width="100%"><tr><td>
    <div align="center" id="bldcontent">
      <a href="http://www.opendocspublishing.com/"><img src="../images/opendocs.png" width="63" height="76" border="0"></a>
      <br>
      <div class="symbol">Your OpenSource Publisher&#153;</div>
    </div>
    
  </td></tr></table>
  
  <div align="center" class="author">
      	<a href="../products.lxp.html">Products</a>
	&nbsp;|&nbsp;
	<a href="../wheretobuy.lxp.html">Where to buy</a>
	&nbsp;|&nbsp;
	<a href="../bookstore.lxp.html">Retailers</a>
	&nbsp;|&nbsp;
	<a href="../FAQ.lxp.html">FAQ</a>
	&nbsp;|&nbsp;
        <a href="../writeforus.lxp.html">Write for Us.</a>
        &nbsp;|&nbsp;
        <a href="x6082.htm#contact">Contact Us.</a>
  </div>
    <table border="0" cellspacing="3" cellpadding="0" width="100%"><tr><td width="100%">
      <div class="content">
        <table border="0" cellspacing="2" cellpadding="0" width="100%"><tr><td width="100%">
          <div align="center">
<H4 CLASS="AUTHOR"><A NAME="AEN5">Boudewijn Rempt</A>
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
<img src="ODPyQT125.png">
</a>
<br>
ISBN: 0-97003300-4-4
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
Available from bookstores everywhere or you can order it here.
</a>
<p>
You can download the source files for the book <a href="pyqtsrc.tgz">(code / eps) here.</a>
<hr>
</div>

          
          <HTML
><HEAD
><TITLE
>Implementing configurations settings for
      Kalam</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.72
"><LINK
REL="HOME"
TITLE="GUI Programming with Python: QT Edition"
HREF="book1.htm"><LINK
REL="UP"
TITLE="Application Configuration"
HREF="c6013.htm"><LINK
REL="PREVIOUS"
TITLE="The Python way of handling configuration
      settings"
HREF="x6053.htm"><LINK
REL="NEXT"
TITLE="Settings in Qt 3.0"
HREF="x6300.htm"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GUI Programming with Python: QT Edition</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A accesskey="P" href="x6053.htm">Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 18. Application Configuration</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A accesskey="N" href="x6300.htm">Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
>Implementing configurations settings for
      <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
></A
></H1
><P
>Working with configuration settings can be
      divided into two main procedures: giving your application
      classes access to the configuration data, and loading and saving
      that data. We'll start by looking at the first problem, and then
      at loading and saving. In the next chapter, we'll round out
      <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
> by creating a preferences
      dialog.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>Handling configuration data in your
        application</A
></H2
><P
>Before we start saving and restoring
        configuration settings, we should have a clear idea of how to
        handle them in the application. Configuration data typically
        must be available everywhere in the application, because all
        objects must be able to query and store settings at
        will.</P
><P
>In other languages, such as Visual
        Basic, you would use a module with global variables to store
        configuration data; in a language like Java or C++, you would
        use a singleton object&#8212;that is, an object with a hidden
        constructor that can only be instantiated once. Python,
        however, does not support these constructions.</P
><P
>Of course, there is an alternative. In a sense,
        class definitions are global. Every module that imports a
        certain class gets exactly the same class. Keep in mind that a
        class is just an object, of the type
        <TT
CLASS="VARNAME"
>class</TT
>. You can associate variables not only
        with an object, as in:</P
><PRE
CLASS="PROGRAMLISTING"
>class SomeClass:

   def __init__(self):
       self.someVariable=1

someInstance=SomeClass()
print someInstance.someVariable
    </PRE
><P
>But also with a class:</P
><PRE
CLASS="PROGRAMLISTING"
>class SomeClass:

    classVariable=1

print SomeClass.classVariable
    </PRE
><P
>These class variables are accessed via the
        <SPAN
><I
CLASS="EMPHASIS"
>name</I
></SPAN
> of the class, instead of the name of
        an instance of that class. Class variables are shared by all
        instances of a class.</P
><P
>The ideal solution to creating a
        "global" configuration repository is to define a class that
        contains all configuration data as class variables. It's also
        possible to encapsulate the configuration data repository in a
        single class variable. You cannot call functions on a
        class - there is no equivalent to the &#8216;static' methods of
        Java. If we need functions to work on the configuration data,
        we must either define those functions at module level, or as
        functions of an object that is a class variable of the
        configuration module. An example would be a function to create
        a <TT
CLASS="CLASSNAME"
>QFont</TT
> out of a fontname
        string.</P
><P
>Well &#8212; that was the theory. Let's
        now look at the code needed to implement configuration data
        for <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
>. It's pretty similar to
        the snippets we saw above:</P
><PRE
CLASS="PROGRAMLISTING"
>"""
kalamconfig.py - Configuration class for the Kalam Unicode Editor

copyright: (C) 2001, Boudewijn Rempt
email:     boud@rempt.xs4all.nl
"""

import sys, os
from qt import *


class Config:

    APPNAME = "kalam"
    APPVERSION = "ch13"
    CONFIGFILE = ".kalam-ch13"

    currentStyle="Platinum"
    viewmanager="tabmanager"

    app_x=0
    app_y=0
    app_w=640
    app_h=420

    fontfamily="courier"
    pointsize=12
    weight=50
    italic=0
    encoding=22


def getApplicationFont():
    return QFont(Config.fontfamily,
                 Config.pointsize,
                 Config.weight,
                 Config.italic,
                 Config.encoding )
      </PRE
><P
>As you can see, it's just a simple matter of a class with a bunch
        of class variables that represent pertinent values.
        However,
        because these values will be saved to a file, you cannot
        associate real objects with the keys. To make it easier to
        retrieve a font based on the values stored in
        the configuration file, there is module-level helper function,
        <TT
CLASS="FUNCTION"
>getApplicationFont()</TT
>, which constructs a
        <TT
CLASS="CLASSNAME"
>QFont</TT
> on the fly.</P
><P
>A similar function exists to set the font:</P
><PRE
CLASS="PROGRAMLISTING"
>def setApplicationFont(qfont):
     Config.fontfamily = qfont.family()
     Config.pointsize = qfont.pointSize()
     Config.weight = qfont.weight()
     Config.italic = qfont.italic()
     Config.encoding = qfont.encoding()
      </PRE
><P
>As you can see, we store our settings in
        a flat namespace, in which every key must be unique. This is
        just like the properties system used in Java, but more complex
        systems can be very useful. For instance, the Windows registry
        is one gigantic tree, and even the files created by
        <TT
CLASS="FILENAME"
>ConfigParser</TT
> have sections and
        subsections. For highly complex configuration needs, there is
        the <TT
CLASS="FILENAME"
>shlex</TT
> Python module, which you can
        use to define configuration languages.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>Saving and loading the configuration data</A
></H2
><P
>Retrieving and saving the configuration
        data can be made as complex or easy as you want. We have
        already discussed the possibility of using
        <TT
CLASS="FILENAME"
>_winreg</TT
> or
        <TT
CLASS="FILENAME"
>ConfigParser</TT
> for the saving and
        retrieving of configuration data.</P
><P
>What we are going to, however, is far
        more simple. When we load the settings, we just read every
        line in the configuration file, and add a variable to the
        <TT
CLASS="CLASSNAME"
>Config</TT
> class that represents the
        value:</P
><PRE
CLASS="PROGRAMLISTING"
>def readConfig(configClass = Config):
    sys.stderr.write( "Initializing configuration\n")
    try:
        for line in open(os.path.join(os.environ["HOME"],
                                      Config.CONFIGFILE)).readlines():
            k, v=tuple(line.split("="))
            v=v[:-1]
            if v=="None\n":
                v=None
            elif type:
               try:
                    v=int(v)
                except ValueError:
                    pass
            setattr(configClass, k, v)
    except IOError:
        sys.stderr.write( "Creating first time configuration\n")
      </PRE
><P
>To add the variable to the
        <TT
CLASS="CLASSNAME"
>Config</TT
> we use the standard Python
        function <TT
CLASS="FUNCTION"
>setattr()</TT
> &#8212; this function
        is one of the delights that make Python so dynamic.</P
><P
>Note the special treatment of the value
        that is represented by "None" in the configuration file: if
        "None" is encountered the value of the configuration key is
        set to a real None object. This contrast with the situation
        where the value is simply empty: then the value is set to an
        empty string ("").</P
><P
>Currently, the configuration file format
        only supports two types: strings and integers. The distinction
        is made by brute force: we simply try to convert the value to
        an integer, and if we succeed, it stays an integer. If the
        conversion raises a <TT
CLASS="VARNAME"
>ValueError</TT
>, we assume
        the value should remain a string.</P
><P
>By now you might be wondering
        <SPAN
><I
CLASS="EMPHASIS"
>when</I
></SPAN
> we will be reading in the
        configuration values. The simple answer is that we will do so
        when the <TT
CLASS="FILENAME"
>KalamConfig</TT
> module is first
        imported. At the bottom of the module the function
        <TT
CLASS="FUNCTION"
>readConfig(Config)</TT
> is called, and is only
        executed once:</P
><PRE
CLASS="PROGRAMLISTING"
>readConfig()
      </PRE
><P
>Saving the configuration values to disk
        is a simple matter of looping over the contents of the
        attributes of the <TT
CLASS="CLASSNAME"
>Config</TT
> class &#8212;
        that is, the <TT
CLASS="VARNAME"
>__dict__</TT
>,
        <TT
CLASS="VARNAME"
>__methods__</TT
> and
        <TT
CLASS="VARNAME"
>__members__</TT
> dictionaries that are part of
        the object's hidden attributes. We retrieve these with the
        <TT
CLASS="FUNCTION"
>dir()</TT
> function:</P
><PRE
CLASS="PROGRAMLISTING"
>def writeConfig(configClass = Config):
    sys.stderr.write( "Saving configuration\n")
    configFile=open(os.path.join(os.environ["HOME"],".kalamrc"),"w+")
    for key in dir(Config):
        if key[:2]!='__':
            val=getattr(Config, key)
            if val==None or val=="None":
                line=str(key) + "=\n"
            else:
                line=str(key) + "=" + str(val) + "\n"
            configFile.write(line)
    configFile.flush()
      </PRE
><P
>The actual values are retrieved with
        the opposite of <TT
CLASS="FUNCTION"
>setattr()</TT
>:
        <TT
CLASS="FUNCTION"
>getattr()</TT
>. As a first check, attributes
        with a double underscore as prefix are not saved: those are
        internal attributes to the <TT
CLASS="CLASSNAME"
>Config</TT
>
        class. If the value is the <TT
CLASS="VARNAME"
>None</TT
> object, we
        print the string "None". Because it is quite possible that
        some values are <TT
CLASS="CLASSNAME"
>QString</TT
> objects, and
        because you cannot save these, everything is converted to a plain
        Python string.</P
><P
>Finally, you might need functions that get and set more
      complex objects in the <TT
CLASS="CLASSNAME"
>Config</TT
>. These can
      be simple module level functions that work on the class:</P
><PRE
CLASS="PROGRAMLISTING"
>def getTextFont():
    return QFont(Config.fontfamily,
                 Config.pointsize,
                 Config.weight,
                 Config.italic,
                 Config.encoding )

def setTextFont(qfont):
     Config.fontfamily = qfont.family()
     Config.pointsize = qfont.pointSize()
     Config.weight = qfont.weight()
     Config.italic = qfont.italic()
     Config.encoding = qfont.encoding()
      </PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>Using configuration data from the application</A
></H2
><P
>By now we have a simple configuration
        data mechanism, and it's time to use it. Earlier we defined a
        few settings: the position and size of the application window,
        the widget style that is to be used, and the interface
        paradigm. First, we will write some code to actually use these
        settings. Then we will write code to save changes when the
        application is closed.</P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
>Font settings</A
></H3
><P
>The font to be used in the editor window can be
        set and retrieved with the get and set functions we defined
        above. The <TT
CLASS="CLASSNAME"
>KalamView</TT
> class is the place
        to use this setting.</P
><PRE
CLASS="PROGRAMLISTING"
>"""
from qt import *
import kalamconfig
from resources import TRUE, FALSE

class KalamView(QWidget):

    def __init__(self, parent, doc, *args):
        apply(QWidget.__init__,(self, parent) + args)
        ...
        self.editor=QMultiLineEdit(self)
        self.editor.setFont(kalamconfig.getTextFont())
        self.layout.addWidget(self.editor)
      </PRE
><P
>We import the configuration module,
          <SPAN
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> the <TT
CLASS="CLASSNAME"
>Config</TT
>
          class from the configuration module. After creating the
          editor widget, we simply set the font with a call to
          <TT
CLASS="FUNCTION"
>self.editor.setFont(kalamconfig.getTextFont())</TT
>.
          </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
>Window geometry</A
></H3
><P
>Applying the geometry is just as easy.
          It's very pleasant for users when an application pops up its
          windows at the same place and in the same size as the user
          left them. This is part of session management, which is very
          advanced in the KDE environment, but less so for Windows. Qt
          3 offers support for session management with
          <TT
CLASS="CLASSNAME"
>QSessionManager</TT
> and
          <TT
CLASS="CLASSNAME"
>QApplication</TT
>, but we'll take care of
          session management ourselves at this time.</P
><P
>Setting the correct size and position
          of a window, and also the correct widget style, is done in
          the central application object,
          <TT
CLASS="CLASSNAME"
>KalamApp</TT
>:</P
><PRE
CLASS="PROGRAMLISTING"
>from qt import *
...

import kalamconfig
...

class KalamApp(QMainWindow):
    """KalamApp is the toplevel application window of the kalam unicode editor
    application.
    """
    def __init__(self, *args):
        apply(QMainWindow.__init__,(self, ) + args)

        ...

        self.initSettings()

        ...

    #
    # GUI initialization
    #
    def initSettings(self):
        qApp.setStyle(kalamconfig.getStyle())
        self.setGeometry(kalamconfig.Config.app_x,
                         kalamconfig.Config.app_y,
                         kalamconfig.Config.app_w,
                         kalamconfig.Config.app_h)

        </PRE
><P
>Here, too, we import the
          <TT
CLASS="FILENAME"
>kalamconfig</TT
> module. The function
          <TT
CLASS="FUNCTION"
>initSettings()</TT
> is called from the
          constructor {<TT
CLASS="FUNCTION"
>__init__()</TT
>}
          </P
><P
>This function will be extended with
          other application level settings during development of
          <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
>.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
>Determining the widget style</A
></H3
><P
> First, we set the desired widget
          style. Users can also set the widget style using a
          command-line option, and Qt can even figure out which style
          fits best with a users platform. But some people have strong
          preferences, and will want to configure their preferred
          style. It is easy enough to determine and use the platform
          default if no special style is set.
          </P
><P
>The <TT
CLASS="FUNCTION"
>getStyle()</TT
> and
          <TT
CLASS="FUNCTION"
>setStyle</TT
> are quite interesting, from a
          Python point of view:</P
><PRE
CLASS="PROGRAMLISTING"
>def __extractStyle(style):
    if type(style) == InstanceType:
        return style.__class__.__name__
    elif type(style) == StringType:
        return style
    else:
        return "QPlatinumStyle"
        </PRE
><P
>I wanted this to be as flexible as
          possible, showing the dynamic nature of Python. The
          <TT
CLASS="FUNCTION"
>__extractStyle</TT
> function takes the
          current style object that is used by the application. We
          find this by calling <TT
CLASS="FUNCTION"
>qApp.style()</TT
>.
          <TT
CLASS="VARNAME"
>qApp</TT
> is a global variable that points to
          the <TT
CLASS="CLASSNAME"
>QApplication</TT
> object.</P
><P
>An instance in Python has a number of
          &#8216;hidden' fields and methods that each have a special
          meaning. One of these is <TT
CLASS="FUNCTION"
>__init__()</TT
>,
          which is called when the object is first created. Another is
          <TT
CLASS="VARNAME"
>__class__</TT
>, which returns the class that
          the object was created from. You can use this to make more
          instances, but in this case
          we are interested in the string that contains the name of
          the class. You can retrieve the name with another &#8216;hidden'
          variable of
          the <TT
CLASS="CLASSNAME"
>class</TT
> class:
          <TT
CLASS="VARNAME"
>__name__</TT
>.</P
><PRE
CLASS="PROGRAMLISTING"
>def setStyle(style):
    if type(style) == types.StringType:
        Config.currentStyle = style
    elif type(style) == types.InstanceType:
        Config.currentStyle = __extractStyle(style)
      </PRE
><P
>Setting the style in the context of
      <TT
CLASS="FILENAME"
>kalamconfig</TT
> means setting the
      "currentStyle" attribute of <TT
CLASS="CLASSNAME"
>Config</TT
> to a
      string that represents the style. If the input to
      <TT
CLASS="FUNCTION"
>setStyle()</TT
> is already a string (that is, if the type
      is <TT
CLASS="VARNAME"
>types.StringType</TT
>), then we simply set
      it. Otherwise, we use the function defined above to get a string
      that equals the name of the style class.</P
><PRE
CLASS="PROGRAMLISTING"
>def getStyle():
    # Basic sanity check - you don't want to eval arbitrary code
    if not hasattr(Config, "currentStyle"):
        print "ok", repr(qApp.style())
        Config.currentStyle = __extractStyle(qApp.style())

    if (Config.currentStyle[0] != "Q" or
        Config.currentStyle[-5:] != "Style"  or
        Config.currentStyle.find(" ") &#62; 0):
        Config.currentStyle = "QPlatinumStyle"

    try:
        # you shouldn't use eval for this, but it is a nice opportunity
        # for showing how it works. Normally you'd use a dictionary of
        # style names.
        return eval(Config.currentStyle)()
    except NameError, e:
        print "No such style: defaulting to Platinum"
        return QPlatinumStyle()
      </PRE
><P
>Getting a <TT
CLASS="CLASSNAME"
>QStyle</TT
>
          object of the right type is a bit more complex. Of course,
          you will most often use a simple dictionary that maps style
          names to style classes:</P
><PRE
CLASS="PROGRAMLISTING"
>        styleDict = { "platinum": QPlatinumStyle, ...}
      </PRE
><P
>This is not particularly flexible. Here,
          we use <TT
CLASS="FUNCTION"
>eval</TT
> to create an object from
          the name of a class. Look carefully at:</P
><PRE
CLASS="PROGRAMLISTING"
>        return eval(Config.currentStyle)()
      </PRE
><P
>This means that, if the variable
          <TT
CLASS="VARNAME"
>Config.currentStyle</TT
> contains a string
          that is equal to classname and that is known to Python (that is,
          it can be found in one of the imported modules),
          <TT
CLASS="FUNCTION"
>eval()</TT
> will return that class. The
          brackets after eval make an instance of the class.</P
><P
>Beware: using
          <TT
CLASS="FUNCTION"
>eval</TT
> is <SPAN
><I
CLASS="EMPHASIS"
>dangerous</I
></SPAN
>.
          For example, what if someone hacked your
          <TT
CLASS="FILENAME"
>.kalam-ch13</TT
> configuration file and set
          the entry <TT
CLASS="LITERAL"
>currentStyle</TT
> to
          <TT
CLASS="LITERAL"
>os.rmdir('/')</TT
>? If you were fool enough to
          run <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
> as root on Unix, you'd
          lose your system&#8212;irretrievably.</P
><P
>This is why I checked the existence
          and believability of the <TT
CLASS="VARNAME"
>currentStyle</TT
>
          string before
          <TT
CLASS="FUNCTION"
>eval</TT
>-ing it. I only used
          <TT
CLASS="FUNCTION"
>eval</TT
> to show you that it exists&#8212;
          for your own sake, don't use <TT
CLASS="FUNCTION"
>eval</TT
>
          trivially! We'll return to <TT
CLASS="FUNCTION"
>eval</TT
> and its
          friends in <A href="c6996.htm">Chapter 20</A
>.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
>Setting the viewmanager</A
></H3
><P
>The last task we handle in this
          chapter is the choosing of the view manager. The available
          choices include tabbed windows, mini-windows, splitters,
          stacks &#8212; the lot. This time, we will use a dictionary
          that maps viewmanager names to actual classes. This is only
          to show you how it works - in general, it's a good rule to
          not mix and match approaches as we have done here, but to
          choose one method, and stick to it.</P
><PRE
CLASS="PROGRAMLISTING"
>"""
kalamconfig.py - Configuration class for the Kalam Unicode Editor

copyright: (C) 2001, Boudewijn Rempt
email:     boud@rempt.xs4all.nl
"""

import sys, os, types
from qt import *

import tabmanager, listspace, splitspace, stackspace, workspace

workspacesDictionary = {
    "tabmanager" : tabmanager.TabManager,
    "listspace"  : listspace.ListSpace,
    "splitspace" : splitspace.SplitSpace,
    "stackspace" : stackspace.StackSpace,
    "workspace"  : workspace.WorkSpace,
    }

class Config:
...
        </PRE
><P
>First, a dictionary
          (<TT
CLASS="VARNAME"
>workspacesDictionary</TT
>) is created that
          contains a mapping from strings to the actual classes. Of
          course, in order to be able to access those classes, they
          will have to be imported.</P
><PRE
CLASS="PROGRAMLISTING"
>def getViewManager():
    try:
        return workspacesDictionary[Config.viewmanager]
    except:
        return tabmanager.TabManager

def setViewManager(viewmanager):
    Config.viewmanager = viewmanager.__class__.__name__
        </PRE
><P
>These two functions get and set the
          viewmanager style. If the style given in
          <TT
CLASS="CLASSNAME"
>Config</TT
> doesn't exist, a
          <TT
CLASS="VARNAME"
>KeyError</TT
> will be raised, in which case we
          simply return a sensible default.</P
><P
>The
          <TT
CLASS="FUNCTION"
>getViewManager()</TT
> is called from the
          <TT
CLASS="FUNCTION"
>initWorkSpace()</TT
> function in
          <TT
CLASS="FILENAME"
>kalamapp.py</TT
>:</P
><PRE
CLASS="PROGRAMLISTING"
>    ...
    def initWorkSpace(self):
        workspace = kalamconfig.getViewManager()(self)
        self.setCentralWidget(workspace)
        return workspace
    ...
        </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>Catching the changes when the application closes</A
></H2
><P
>The configuration should be written to a file
      when the app closes. There are two places where
      <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
> can end:
      <TT
CLASS="FUNCTION"
>slotFileQuit()</TT
>, and in the eventhandler
      <TT
CLASS="FUNCTION"
>eventFilter()</TT
>.</P
><PRE
CLASS="PROGRAMLISTING"
>    ...
    #
    # Slot implementations
    #

    def slotFileQuit(self):
        try:
            self.docManager.closeAllDocuments()
        except:
            return
        kalamconfig.writeConfig()
        qApp.quit()
    ...
    #
    # Toplevel event filter
    #
    ...
    def eventFilter(self, object, event):
        if (event.type() == QEvent.Close):
            if (object&#60;&#62;self):
                if self.docManager.closeView(object):
                    event.accept()
                else:
                    event.ignore()
            else:
                try:
                    self.docManager.closeAllDocuments()
                    kalamconfig.writeConfig()
                    event.accept()
                except Exception, e:
                    event.ignore()
        return QWidget.eventFilter(self, object, event)
     ...
      </PRE
><P
>After all, it is simply a matter of calling
      <TT
CLASS="FUNCTION"
>writeConfig()</TT
> at the right moment.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A accesskey="P" href="x6053.htm">Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="H" href="book1.htm">Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A accesskey="N" href="x6300.htm">Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>The Python way of handling configuration
      settings</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="U" href="c6013.htm">Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Settings in Qt 3.0</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
      </td>
      </tr>
      </table>
      </td>
    </tr>
  </table>
  
    
