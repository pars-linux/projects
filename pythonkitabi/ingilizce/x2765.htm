

  
  <table border="0" cellspacing="0" cellpadding="3" width="100%"><tr><td>
    <div align="center" id="bldcontent">
      <a href="http://www.opendocspublishing.com/"><img src="../images/opendocs.png" width="63" height="76" border="0"></a>
      <br>
      <div class="symbol">Your OpenSource Publisher&#153;</div>
    </div>
    
  </td></tr></table>
  
  <div align="center" class="author">
      	<a href="../products.lxp.html">Products</a>
	&nbsp;|&nbsp;
	<a href="../wheretobuy.lxp.html">Where to buy</a>
	&nbsp;|&nbsp;
	<a href="../bookstore.lxp.html">Retailers</a>
	&nbsp;|&nbsp;
	<a href="../FAQ.lxp.html">FAQ</a>
	&nbsp;|&nbsp;
        <a href="../writeforus.lxp.html">Write for Us.</a>
        &nbsp;|&nbsp;
        <a href="x2765.htm#contact">Contact Us.</a>
  </div>
    <table border="0" cellspacing="3" cellpadding="0" width="100%"><tr><td width="100%">
      <div class="content">
        <table border="0" cellspacing="2" cellpadding="0" width="100%"><tr><td width="100%">
          <div align="center">
<H4 CLASS="AUTHOR"><A NAME="AEN5">Boudewijn Rempt</A>
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
<img src="ODPyQT125.png">
</a>
<br>
ISBN: 0-97003300-4-4
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
Available from bookstores everywhere or you can order it here.
</a>
<p>
You can download the source files for the book <a href="pyqtsrc.tgz">(code / eps) here.</a>
<hr>
</div>

          
          <HTML
><HEAD
><TITLE
>Widget foundations: QWidget</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.72
"><LINK
REL="HOME"
TITLE="GUI Programming with Python: QT Edition"
HREF="book1.htm"><LINK
REL="UP"
TITLE="Qt Class Hierarchy"
HREF="c2591.htm"><LINK
REL="PREVIOUS"
TITLE="Application classes"
HREF="x2693.htm"><LINK
REL="NEXT"
TITLE="Basic widgets"
HREF="x2976.htm"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GUI Programming with Python: QT Edition</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A accesskey="P" href="x2693.htm">Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 10. Qt Class Hierarchy</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A accesskey="N" href="x2976.htm">Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
>Widget foundations: QWidget</A
></H1
><P
>All Qt widgets and all visible components are founded upon
      <TT
CLASS="CLASSNAME"
>QWidget</TT
> &#8212; this monster class provides all
      event handling, all style handling and countless other chores.
      To help with the handling of these tasks, there are other
      classes, such as <TT
CLASS="CLASSNAME"
>QPixmap</TT
>,
      <TT
CLASS="CLASSNAME"
>QColor</TT
>, <TT
CLASS="CLASSNAME"
>QFont</TT
> or
      <TT
CLASS="CLASSNAME"
>QStyle</TT
>.</P
><P
><TT
CLASS="CLASSNAME"
>QWidget</TT
> can be useful to build your
      own widgets on, provided you are prepared to do all your own
      painting &#8212; this includes buffering in case your widget gets
      a <TT
CLASS="FUNCTION"
>paintEvent</TT
> call! Consider the next
      snippet, which is an extension of the event1.py example:</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 10-4. event2.py - using QWidget to create a custom,
        double-buffered drawing widget.</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#
# event2.py
#
from qt import *
import sys

class Painting(QWidget):

    def __init__(self, *args):
        apply(QWidget.__init__,(self, ) + args)
        self.buffer = QPixmap()

    def paintEvent(self, ev):
        # blit the pixmap
        bitBlt(self, 0, 0, self.buffer)

    def mouseMoveEvent(self, ev):
        self.p = QPainter()
        self.p.begin(self.buffer)
        self.p.drawLine(self.currentPos, ev.pos())
        self.currentPos=QPoint(ev.pos())
        self.p.flush()
        self.p.end()
        bitBlt(self, 0, 0, self.buffer)
                
    def mousePressEvent(self, ev):
        self.p = QPainter()
        self.p.begin(self.buffer)
        self.p.drawPoint(ev.pos())
        self.currentPos=QPoint(ev.pos())
        self.p.flush()
        self.p.end()
        bitBlt(self, 0, 0, self.buffer)
        
    def resizeEvent(self, ev):
        tmp = QPixmap(self.buffer.size())
        bitBlt(tmp, 0, 0, self.buffer)
        self.buffer.resize(ev.size())
        self.buffer.fill()
        bitBlt(self.buffer, 0, 0, tmp)
                           
class MainWindow(QMainWindow):

    def __init__(self, *args):
        apply(QMainWindow.__init__, (self,) + args)
        self.painting=Painting(self)
        self.setCentralWidget(self.painting)
        
def main(args):
  app=QApplication(args)
  win=MainWindow()
  win.show()
  app.connect(app, SIGNAL("lastWindowClosed()")
                 , app
                 , SLOT("quit()")
                 )
  app.exec_loop()
  
if __name__=="__main__":
  main(sys.argv)
      </PRE
></DIV
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>event2.py - persistent drawing</P
></DIV
></P
></DIV
><P
>By drawing to <TT
CLASS="CLASSNAME"
>QPixmap</TT
> instead of
      to <TT
CLASS="CLASSNAME"
>QWidget</TT
>, and
      <SPAN
><I
CLASS="EMPHASIS"
>blitting</I
></SPAN
> the contents of that pixmap to the
      widget, the drawing will be kept. Note also how much smoother
      the drawing feels, despite the extra work the script has to do.
      This technique is called double buffering, and is the alpha
      and the omega of graphics programming. Of course, there's still
      a small problem with resizing... In fact, if you want to build
      your own widgets from the ground up using QWidget, you're always
      in for more work than you reckoned with.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>QColor</A
></H2
><P
>The <TT
CLASS="CLASSNAME"
>QColor</TT
> class
        represents any color that can be used in PyQt. You can
        instantiate a new color either by using an RGB
        (red-green-blue) value, an HSV (hue-saturation-value) value,
        or a name. The X11 system used on Unix provides a database
        full of rather poetic color names like &#8216;Old Lace',
        &#8216;Royal Blue' and &#8216;Peach Puff' &#8212;you can use
        these names instead of hexadecimal numbers. The Windows
        version of PyQt has a copy of this database, so it's quite
        portable. If you replace the
        <TT
CLASS="FUNCTION"
>resizeEvent()</TT
> in the event2.py example
        with the following code, you'll see the effect:</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 10-5. snippet from event3.py - a peach puff drawing
          board</B
></P
><PRE
CLASS="PROGRAMLISTING"
>...
    def resizeEvent(self, ev):
        tmp = QPixmap(self.buffer.size())
        bitBlt(tmp, 0, 0, self.buffer)
        self.buffer.resize(ev.size())
        self.buffer.fill(QColor("peachpuff"))
        bitBlt(self.buffer, 0, 0, tmp)
...
        </PRE
></DIV
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>event3.py</P
></DIV
></P
></DIV
><P
>A final note on colors: the way you set
        the colors of a widget have been changed between Qt2 and Qt3.
        Where you first used
        <TT
CLASS="FUNCTION"
>setBackgroundColor()</TT
>, you'd now use
        <TT
CLASS="FUNCTION"
>setEraseColor()</TT
>. Yes, there is a logic
        behind this change of name, but it is very specious, and the
        change broke almost all my code. The erase color is the color
        that Qt uses to clear away, or erase, all the pixels that had
        been painted just before they are painted again in a
        paint event.</P
><P
>When you're designing complex widgets,
        you will want to investigate
        <TT
CLASS="FUNCTION"
>setBackgroundMode</TT
> and the
        <TT
CLASS="VARNAME"
>BackgroundMode</TT
> flags.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>QPixmap, QBitmap and QImage</A
></H2
><P
>We have already been using a
        <TT
CLASS="CLASSNAME"
>QPixMap</TT
> to double buffer the
        scribblings in the previous two examples.
        <TT
CLASS="CLASSNAME"
>QPixmap</TT
> is not the only image class
        PyQt offers: there's also <TT
CLASS="CLASSNAME"
>QBitmap</TT
>,
        which is just like <TT
CLASS="CLASSNAME"
>QPixmap</TT
>, but for
        black and white images only, and
        <TT
CLASS="CLASSNAME"
>QImage</TT
>. Where
        <TT
CLASS="CLASSNAME"
>QPixmap</TT
> and
        <TT
CLASS="CLASSNAME"
>QBitmap</TT
> are optimized for drawing (and
        then showing on screen or on a printer),
        <TT
CLASS="CLASSNAME"
>QImage</TT
> is optimized for reading and
        writing (together with the <TT
CLASS="CLASSNAME"
>QImageIO</TT
>
        class), and for manipulating the actual pixels of an image.
        There's another image-related class,
        <TT
CLASS="CLASSNAME"
>QPicture</TT
>, which can be used to record
        drawing operations and replay them later. The recorded paint
        events can then be stored in a file and reloaded later on.
        Those files are called <SPAN
><I
CLASS="EMPHASIS"
>meta-files</I
></SPAN
> &#8212;
        but they're in a special Qt format. In Qt 3,
        <TT
CLASS="CLASSNAME"
>QPicture</TT
> also supports the standard
        scalable vector graphics format, svg. If you want to create a
        complex vector-drawing application you'd be well advised to
        stick to this standard.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>QPainter</A
></H2
><P
>A <TT
CLASS="CLASSNAME"
>QPainter</TT
> object
        is used to efficiently paint on any paintdevice using a
        variety of primitive graphics, such as simple dots or lines,
        bezier curves, polygons, strings of text (using a particular
        font) or pixmaps. Drawings can be modified, for instance by
        shearing or rotating, and parts can be erased or clipped. We
        have already used a QPainter to draw the scribbly lines in
        previous examples.
        </P
><P
>Paint devices can be:</P
><P
></P
><UL
><LI
><P
>pictures:
              <TT
CLASS="CLASSNAME"
>QPicture</TT
></P
></LI
><LI
><P
>pixmaps:
              <TT
CLASS="CLASSNAME"
>QPixmap</TT
></P
></LI
><LI
><P
>printers:
              <TT
CLASS="CLASSNAME"
>QPrinter</TT
></P
></LI
><LI
><P
>widgets <TT
CLASS="CLASSNAME"
>: QWidget</TT
> (and
              all children of <TT
CLASS="CLASSNAME"
>QWidget</TT
>)
            </P
></LI
></UL
><P
>What can be drawn on one device, can
        be drawn on all devices, so it's uncommonly easy to print on
        paper what can be drawn on screen. Copying batches of pixels
        from one paint device to another is blindingly fast if you use
        the bitBlt global function, as we did above for our
        double-buffered graphics editor.</P
><P
>Note that you cannot create
        <SPAN
><I
CLASS="EMPHASIS"
>any</I
></SPAN
> paint device until you have created a
        <TT
CLASS="CLASSNAME"
>QApplication</TT
>. This includes
        <TT
CLASS="CLASSNAME"
>QPixmap</TT
>s. The following variant on
        action.py won't work, even though it seems a
        <SPAN
><I
CLASS="EMPHASIS"
>good</I
></SPAN
> idea to pre-create the pixmap,
        instead of converting the xpm data on constructing the
        <TT
CLASS="CLASSNAME"
>QAction</TT
>:</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 10-6. fragment from action2.py - You cannot create a
            QPixmap before a QApplication</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#
# action2.py
#

import sys
from qt import *

connectIcon=QPixmap(["16 14 5 1",
             " 	c None",
             ".	c black",
             "X	c gray50",
             "o	c red",
             "O	c yellow",
             "                ",
             "          .     ",
             "       X .X     ",
             "      XooX  .   ",
             "     Xoooo .X   ",
             "    XooooooX    ",
             "    XooooooX    ",
             "    XoooooX.    ",
             "    XooooX.     ",
             "   XOXXXX.      ",
             "  XOXX...       ",
             " XOXX           ",
             "  XX            ",
             "  X             "
             ])

class MainWindow(QMainWindow):

    def __init__(self, *args):
        apply(QMainWindow.__init__, (self, ) + args)
...
        self.action.setIconSet(QIconSet(connectIcon))
...
        </PRE
></DIV
><P
>Running this gives the following result:</P
><PRE
CLASS="SCREEN"
>boudewijn@maldar:~ &#62; python action2.py
QPaintDevice: Must construct a QApplication before a QPaintDevice
Aborted
      </PRE
><P
><A href="c7391.htm">Chapter 21</A
> deals with painters and paintdevices
        in quite a lot of detail, while <A href="c8100.htm">Chapter 24</A
> deals
        with printing to paper.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>QFont</A
></H2
><P
>There is no other area where there are so
        many and profound differences between operating systems as
        there is with fonts. And if you take into account the
        difference in font handling between printers and screens, you
        will get a feeling for how difficult it is to get proper and
        dependable cross-platform multi-lingual font support in a
        toolkit.
        </P
><P
>Fortunately, Qt's font support has
        steadily improved, and is now at the point where, provided
        good quality fonts are available on a system, it can offer the
        same excellent screen <SPAN
><I
CLASS="EMPHASIS"
>and</I
></SPAN
> printer support
        on all platforms.</P
><P
>The first issue is the font used for
        drawing labels and other application texts &#8212; sometimes
        called the system font. This naturally differs for each
        system: Windows uses Arial these days, while KDE uses
        Helvetica, CDE Times and OS X a bold Helvetica. Furthermore,
        the system font is also often customized by the user. Text in
        one font takes more room than text in another font &#8212;
        possibly giving ugly display errors. By using Qt's layout
        managers, instead of positioning widgets with pixel-precision
        yourself, you will have little trouble dealing with the
        geometry differences between Window's Arial font and KDE's
        Helvetica standard &#8212; all controls will reflow
        neatly.</P
><P
>For handling fonts in your application
        you can work with <TT
CLASS="CLASSNAME"
>QFont</TT
>. Qt builds its
        own database of available fonts from whatever the system
        provides. You can then access these fonts in a
        system-independent manner, without having to juggle X11 font
        resource names yourself.</P
><P
><TT
CLASS="CLASSNAME"
>QFont</TT
> provides all
        necessary functions to select encodings (or scripts in Qt3),
        font families, styles and sizes. There's also a standard
        dialog available, <TT
CLASS="CLASSNAME"
>QFontDialog</TT
> that you
        can use to let the user select a certain font.</P
><P
>There are serious differences between the
        font system in Qt2 and Qt3. In Qt2, you need to determine
        which character set encoding you need; and you can only use
        the character set encodings that the particular font supports.
        For instance, if your font supports the KOI8 Cyrillic
        encoding, then that is the encoding you can use. The font you
        request has a one-to-one relation with the font files on your
        system.</P
><P
>In Qt3, you select fonts by name, style
        and script (like Cyrillic), and Qt will select the closest
        fitting font. If your widget needs to present text on screen
        that uses characters that cannot be retrieved from the
        selected font, Qt will query all other fonts on your system,
        and assemble a composite, synthetic font that includes all
        characters you need. You lose some control but you gain a
        correct representation of all possible texts&#8212; you can
        use any font for any text in any script.</P
><P
>If you want to set a certain font for the
        entire application, you can use the
        <TT
CLASS="FUNCTION"
>QApplication.setFont</TT
> class function.
        Likewise, everything that descends from
        <TT
CLASS="CLASSNAME"
>QWidget</TT
> also has a
        <TT
CLASS="FUNCTION"
>setFont()</TT
> function.</P
><P
>You can use <TT
CLASS="CLASSNAME"
>QFontInfo</TT
> to
        determine the exact font Qt uses for a certain QFont &#8212; but
        this might be quite slow. An important use of
        <TT
CLASS="CLASSNAME"
>QFontInfo</TT
> with Qt3 is to determine
        whether the font you get was exactly the font you asked for.
        For instance, if you desire a Bembo font, which might not be
        present on your system, you could get something closeish: a
        Times New Roman. Especially for drawing and dtp applications
        it's important to be sure which font is actually used.</P
><P
><TT
CLASS="CLASSNAME"
>QFontMetrics</TT
> can
        be used to determine metrics information about a font. For
        instance, how high the ascenders and descenders are, and how
        wide the widest character is. This is useful if you need to
        determine how much space a line of text takes when printed on
        paper. </P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>Font metrics</P
></DIV
></P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A accesskey="P" href="x2693.htm">Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="H" href="book1.htm">Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A accesskey="N" href="x2976.htm">Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Application classes</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="U" href="c2591.htm">Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Basic widgets</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
      </td>
      </tr>
      </table>
      </td>
    </tr>
  </table>
  
    
