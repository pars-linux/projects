

  
  <table border="0" cellspacing="0" cellpadding="3" width="100%"><tr><td>
    <div align="center" id="bldcontent">
      <a href="http://www.opendocspublishing.com/"><img src="../images/opendocs.png" width="63" height="76" border="0"></a>
      <br>
      <div class="symbol">Your OpenSource Publisher&#153;</div>
    </div>
    
  </td></tr></table>
  
  <div align="center" class="author">
      	<a href="../products.lxp.html">Products</a>
	&nbsp;|&nbsp;
	<a href="../wheretobuy.lxp.html">Where to buy</a>
	&nbsp;|&nbsp;
	<a href="../bookstore.lxp.html">Retailers</a>
	&nbsp;|&nbsp;
	<a href="../FAQ.lxp.html">FAQ</a>
	&nbsp;|&nbsp;
        <a href="../writeforus.lxp.html">Write for Us.</a>
        &nbsp;|&nbsp;
        <a href="index.lxp%3Flxpwrap=x1149.htm#contact">Contact Us.</a>
  </div>
    <table border="0" cellspacing="3" cellpadding="0" width="100%"><tr><td width="100%">
      <div class="content">
        <table border="0" cellspacing="2" cellpadding="0" width="100%"><tr><td width="100%">
          <div align="center">
<H4 CLASS="AUTHOR"><A NAME="AEN5">Boudewijn Rempt</A>
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
<img src="ODPyQT125.png">
</a>
<br>
ISBN: 0-97003300-4-4
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
Available from bookstores everywhere or you can order it here.
</a>
<p>
You can download the source files for the book <a href="pyqtsrc.tgz">(code / eps) here.</a>
<hr>
</div>

          
          <HTML
><HEAD
><TITLE
>      A better Hello World
    </TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.72
"><LINK
REL="HOME"
TITLE="GUI Programming with Python: QT Edition"
HREF="book1.htm"><LINK
REL="UP"
TITLE="Qt Concepts"
HREF="c1036.htm"><LINK
REL="PREVIOUS"
TITLE="      As simple as they come
    "
HREF="x1067.htm"><LINK
REL="NEXT"
TITLE="Designing forms"
HREF="x1214.htm"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GUI Programming with Python: QT Edition</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A accesskey="P" href="index.lxp%3Flxpwrap=x1067.htm">Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 6. Qt Concepts</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A accesskey="N" href="index.lxp%3Flxpwrap=x1214.htm">Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
>A better Hello World</A
></H1
><P
>Of course, you will never write a script
      like the previous one in earnest. While it works, it doesn't
      even show the correct way of setting up a PyQt application. A
      far superior structure is as follows:</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 6-2. hello2.py &#8212; a better hello world</B
></P
><PRE
CLASS="PROGRAMLISTING"
>import sys
from qt import *

class HelloButton(QPushButton):

    def __init__(self, *args):
        apply(QPushButton.__init__, (self,) + args)
        self.setText("Hello World")

class HelloWindow(QMainWindow):

    def __init__(self, *args):
        apply(QMainWindow.__init__, (self,) + args)
        self.button=HelloButton(self)
        self.setCentralWidget(self.button)

def main(args):
    app=QApplication(args)
    win=HelloWindow()
    win.show()
    app.connect(app, SIGNAL("lastWindowClosed()"),
                app, SLOT("quit()"))
    app.exec_loop()

if __name__=="__main__":
    main(sys.argv)
      </PRE
></DIV
><P
>This is more like it! While still boring
      and trivial, this small program shows several important aspects
      of programming with Python and Qt: the subclassing of Qt classes
      in Python, the use of windows and widgets, and the use of
      signals and slots.</P
><P
>In most PyQt applications you will create a
      custom main window class, based on QMainWindow, and at least one
      custom main view widget, based on any Qt widget &#8212; it could
      be a listview, an editor window or a canvas, or, as in this
      case, a simple button. Although PyQt allows you to subclass
      almost any Qt class, you can't base a Python class on more than
      one Qt class at a time.</P
><P
>That is, multiple inheritance of Qt classes
      is not supported. This is seldom (if ever) a problem&#8212;try
      to imagine what a widget that looks like a checkbox and a
      radiobutton at the same time. Using two widgets in one custom
      widgets is another matter, called delegation, and is fully
      supported.</P
><P
>In this script we have subclassed
      <TT
CLASS="CLASSNAME"
>QMainWindow</TT
> to create a custom window
      that contains a pushbutton as its central widget. Almost always,
      a window will have the usual frills around the borders &#8212;
      menus, toolbars and statusbars. This is what QMainWindow is
      designed for. We didn't define any menu items, so the window is
      still a bit bare.</P
><P
>The central part of a window&#8212;the
      letterbox, so to speak&#8212;is where the application-specific
      functionality appears. This is, of course, our button.
      <TT
CLASS="CLASSNAME"
>QMainWindow</TT
> manages the resizing of its
      central widget automatically, as you might have noticed when
      dragging the borders of the window. Also, note the difference in
      geometry between this version of Hello World and the previous
      one: this is caused by the automatic layout handling that
      <TT
CLASS="CLASSNAME"
>QMainWindow</TT
> provides.</P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>A better hello world</P
></DIV
></P
></DIV
><P
>You set the central part of the window with the
      setCentralWidget() method:</P
><PRE
CLASS="PROGRAMLISTING"
>self.setCentralWidget(self.button)
    </PRE
><P
>An application can have zero, one, or more
      windows &#8212; and an application shouldn't close down until
      the last window is closed. <TT
CLASS="CLASSNAME"
>QApplication</TT
>
      keeps count of the number of windows still open and will try to
      notify the world when the last one is closed. This is done
      through the signals/slots system. While this system will be
      discussed in depth in a later chapter, it's sufficiently
      important to warrant some consideration here.</P
><P
>Basically, objects can register an interest in each other,
      and when something interesting happens, all interested objects
      are notified. In this case, the QApplication object wants to
      know when the last window is closed, so it can quit.</P
><PRE
CLASS="PROGRAMLISTING"
>app.connect(app, SIGNAL("lastWindowClosed()"),
            app, SLOT("quit()"))
    </PRE
><P
>Let's analyze this line: the
      <TT
CLASS="VARNAME"
>app</TT
> object makes a connection between a
      signal <TT
CLASS="FUNCTION"
>lastWindowClosed()</TT
> (which is sent by
      the application object itself), and its own
      <TT
CLASS="FUNCTION"
>quit()</TT
> function. Using signals and slots
      from Python is extremely convenient, both for gui work and in
      more abstract situations where a decoupling between objects is
      desirable.</P
><P
>Another example of using signals and slots is in the
        following rewrite of the HelloWindow class:</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 6-3. fragment from hello3.py</B
></P
><PRE
CLASS="PROGRAMLISTING"
>...
class HelloWindow(QMainWindow):

    def __init__(self, *args):
        apply(QMainWindow.__init__, (self,) + args)
        self.button=HelloButton(self)
        self.setCentralWidget(self.button)
        self.connect(self.button, SIGNAL("clicked()"),
                     self, SLOT("close()"))
      </PRE
></DIV
><P
>We have added a line where the
      <TT
CLASS="FUNCTION"
>clicked()</TT
> signal, which is emitted by the
      <TT
CLASS="CLASSNAME"
>QPushButton</TT
> when it is clicked, is
      connected to the <TT
CLASS="FUNCTION"
>close()</TT
> slot of the
      <TT
CLASS="CLASSNAME"
>HelloWindow</TT
> class. Since
      <TT
CLASS="CLASSNAME"
>HelloWindow</TT
> inherits
      <TT
CLASS="CLASSNAME"
>QMainWindow</TT
>, it also inherits all its
      slot functions.</P
><P
>Now, if you click on the button, the
      window closes&#8212;and we have our first interactive PyQt
      application!</P
><P
>An interesting exercise is to create more
      than one window by rewriting the main function:</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 6-4. Fragment from hello5.py</B
></P
><PRE
CLASS="PROGRAMLISTING"
>...
def main(args):
    app=QApplication(args)
    winlist=[]
    for i in range(10):
        win=HelloWindow()
        win.show()
        winlist.append(win)

    app.connect(app, SIGNAL("lastWindowClosed()"),
                app, SLOT("quit()"))
    app.exec_loop()
...
      </PRE
></DIV
><P
>If you run this version of the script, ten windows will
      rapidly pop up on your desktop. You can close each window by
      pressing either the button or using the window controls &#8212;
      the application will only stop when the last one is
      closed.</P
><P
>Try commenting out the line
      <TT
CLASS="LITERAL"
>winlist.append(win)</TT
>:</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 6-5. Fragment from hello4.py</B
></P
><PRE
CLASS="PROGRAMLISTING"
>...
def main(args):
    app=QApplication(args)
    winlist=[]
    for i in range(10):
        win=HelloWindow()
        win.show()
        #winlist.append(win)

    app.connect(app, SIGNAL("lastWindowClosed()"),
                app, SLOT("quit()"))
    app.exec_loop()
...
      </PRE
></DIV
><P
>and see what happens...</P
><P
>This is one of the interesting features in
      Python: in contrast to C++, Python has a garbage collector.
      (Actually, you can choose between a garbage collector and a
      reference counter, but I don't want to get
      <SPAN
><I
CLASS="EMPHASIS"
>that</I
></SPAN
> technical yet). This virtual
      garbage-man will remove unreferenced objects as soon as
      possible. That means that any object that doesn't have a Python
      variable name associated with it will disappear. (Unless the
      object is the child of a <TT
CLASS="CLASSNAME"
>QObject</TT
>; see
      <A href="index.lxp%3Flxpwrap=c2341.htm">Chapter 9</A
> for all the details). If you were to try
      this trick in C++, keeping references would make no difference,
      as C++ does not delete unused objects for you, which can easily
      lead to nasty memory leaks.</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A accesskey="P" href="index.lxp%3Flxpwrap=x1067.htm">Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="H" href="index.lxp%3Flxpwrap=book1.htm">Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A accesskey="N" href="index.lxp%3Flxpwrap=x1214.htm">Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>As simple as they come</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="U" href="index.lxp%3Flxpwrap=c1036.htm">Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Designing forms</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
      </td>
      </tr>
      </table>
      </td>
    </tr>
  </table>
  
    
