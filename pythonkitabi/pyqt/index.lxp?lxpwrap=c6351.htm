

  
  <table border="0" cellspacing="0" cellpadding="3" width="100%"><tr><td>
    <div align="center" id="bldcontent">
      <a href="http://www.opendocspublishing.com/"><img src="../images/opendocs.png" width="63" height="76" border="0"></a>
      <br>
      <div class="symbol">Your OpenSource Publisher&#153;</div>
    </div>
    
  </td></tr></table>
  
  <div align="center" class="author">
      	<a href="../products.lxp.html">Products</a>
	&nbsp;|&nbsp;
	<a href="../wheretobuy.lxp.html">Where to buy</a>
	&nbsp;|&nbsp;
	<a href="../bookstore.lxp.html">Retailers</a>
	&nbsp;|&nbsp;
	<a href="../FAQ.lxp.html">FAQ</a>
	&nbsp;|&nbsp;
        <a href="../writeforus.lxp.html">Write for Us.</a>
        &nbsp;|&nbsp;
        <a href="index.lxp%3Flxpwrap=c6351.htm#contact">Contact Us.</a>
  </div>
    <table border="0" cellspacing="3" cellpadding="0" width="100%"><tr><td width="100%">
      <div class="content">
        <table border="0" cellspacing="2" cellpadding="0" width="100%"><tr><td width="100%">
          <div align="center">
<H4 CLASS="AUTHOR"><A NAME="AEN5">Boudewijn Rempt</A>
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
<img src="ODPyQT125.png">
</a>
<br>
ISBN: 0-97003300-4-4
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
Available from bookstores everywhere or you can order it here.
</a>
<p>
You can download the source files for the book <a href="pyqtsrc.tgz">(code / eps) here.</a>
<hr>
</div>

          
          <HTML
><HEAD
><TITLE
>Using Dialog Windows</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.72
"><LINK
REL="HOME"
TITLE="GUI Programming with Python: QT Edition"
HREF="book1.htm"><LINK
REL="UP"
TITLE="Creating real applications with PyQt"
HREF="p4627.htm"><LINK
REL="PREVIOUS"
TITLE="Conclusion"
HREF="x6342.htm"><LINK
REL="NEXT"
TITLE="Non-modal: Search and
      replace"
HREF="x6734.htm"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GUI Programming with Python: QT Edition</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A accesskey="P" href="index.lxp%3Flxpwrap=x6342.htm">Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A accesskey="N" href="index.lxp%3Flxpwrap=x6734.htm">Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
>Chapter 19. Using Dialog Windows</A
></H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A href="index.lxp%3Flxpwrap=c6351.htm#AEN6357">Modal: a preferences dialog</A
></DT
><DT
><A href="index.lxp%3Flxpwrap=x6734.htm">Non-modal: Search and
      replace</A
></DT
><DT
><A href="index.lxp%3Flxpwrap=x6992.htm">Conclusion</A
></DT
></DL
></DIV
><P
>In this chapter we add a few dialog windows
    to the <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
> program. Dialog windows
    come in two basic flavors: modal and non-modal. Modal dialog
    windows block the interface of you application. Settings dialog,
    file dialogs and such are typically modal. Non-modal dialogs can
    stay open while the user continues working in the application.
    Search and replace or style dialogs are typical examples of
    non-modal dialogs.</P
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
>Modal: a preferences dialog</A
></H1
><P
>We will start with a preferences dialog.
      Nowadays, the taste is for dialogs with a strip of icons to the
      left that somehow indicates what section should be shown. But we
      will start out with a simple tabbed dialog that PyQt supports
      out of the box, and for which we don't have to draw icons
      (that's always the difficult bit, creating the artwork).</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>Designing the dialog</A
></H2
><P
>So: time to fire up the designer module
        of BlackAdder or Qt Designer!</P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>The settings dialog - editor tab</P
></DIV
></P
></DIV
><P
>I like to show a sample of what the user
        selects in the dialog. In this tab, the user can select font,
        text and background color for the editor windows. These
        changes are reflected in the little label with the "Lorem
        ipsum" text. There are two more options: a combobox for
        selecting the wrapping mode (either no wrapping, wrap to the
        maximum line width, or wrap to the width of the window), and a
        spin box to set the maximum line width.</P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>The settings dialog - interface tab</P
></DIV
></P
></DIV
><P
>Most users will not immediately get what
        we mean with "Window view" - in the interface tab w show an
        example of what we mean, too. I propose to make the "Look and
        Feel" selection automatically active, so that doesn't need a
        preview.</P
><P
>To fill in the preview I've snapshotted
        <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
> in all its variations and
        scaled the pictures down a lot. Adding these pictures as
        inline-image data to the dialog would make loading very slow,
        since Python is not so quick in reading bytecode files. It is
        better to create a <TT
CLASS="FILENAME"
>pixmaps</TT
> directory and
        store the pictures there.</P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>The settings dialog - document tab</P
></DIV
></P
></DIV
><P
>As for the document, we need two
        settings: the first is the document encoding. While
        <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
> is meant to be a Unicode
        editor for standard <SPAN
><I
CLASS="EMPHASIS"
>utf8</I
></SPAN
> files, people
        might prefer things like iso-8859-1. This is mere
        window-dressing&#8212;actually loading and saving in encodings
        other than utf-8 will not be implemented for now. The second
        option is about document endings. A text file should end with
        a newline character, and we added code to make sure it does in
        <A href="index.lxp%3Flxpwrap=c5783.htm">Chapter 17</A
>&#8212;ultimately, this should be a
        configuration option.</P
><P
>Of course, during the course of
        development we will expand the contents of these pages, adding
        items when we need them. Someone once remarked that a
        configuration dialog presents the history of design decisions
        that were avoided during development&#8212;and it often feels
        that way indeed.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>Creating the settings dialog window</A
></H2
><P
>The first part of the drill is well
        known: compile the <TT
CLASS="FILENAME"
>frmsettings.ui</TT
> file to
        Python using <B
CLASS="COMMAND"
>pyuic</B
>.
      </P
><PRE
CLASS="SCREEN"
>pyuic -x frmsettings.ui &#62; frmsettings.py
      </PRE
><P
>You can either call this generated
        dialog directly from <TT
CLASS="CLASSNAME"
>KalamApp</TT
>, or you
        can subclass it and add some intelligence. Since intelligence
        is what is needed to synchronize the switches between
        interface paradigm, we will go ahead and add subclass the
        design and add some.
        </P
><PRE
CLASS="PROGRAMLISTING"
>"""
dlgsettings.py - Settings dialog for Kalam.

See: frmsettings.ui

copyright: (C) 2001, Boudewijn Rempt
email:     boud@rempt.xs4all.nl
"""
import os, sys
from qt import *
import kalamconfig

from frmsettings import FrmSettings

class DlgSettings(FrmSettings):

    def __init__(self,
                 parent = None,
                 name = None,
                 modal = 0,
                 fl = 0):
        FrmSettings.__init__(self, parent, name, modal, fl)

        self.textFont = kalamconfig.get("textfont")
        self.textBackgroundColor = kalamconfig.get("textbackground")
        self.textForegroundColor = kalamconfig.get("textforeground")
        self.MDIBackgroundColor = kalamconfig.get("mdibackground")

        self.initEditorTab()
        self.initInterfaceTab()
        self.initDocumentTab()
      </PRE
><P
>The <TT
CLASS="CLASSNAME"
>DlgSettings</TT
>
        dialog is a subclass of <TT
CLASS="CLASSNAME"
>FrmSettings</TT
>,
        which we created with Designer. In the constructor we create
        four objects for housekeeping purposes, to store changed
        settings until the user chooses to apply them by pressing OK,
        or to cancel.</P
><P
>These objects represent the editor font,
        the editor text color, the editor background color and the
        background color of the MDI workspace. As you can see from the
        calls to <TT
CLASS="FILENAME"
>kalamconfig</TT
>, actually
        implementing this dialog necessitated quite a few changes to
        the <TT
CLASS="FILENAME"
>kalamconfig</TT
> module.</P
><P
>The full source of
        <TT
CLASS="FILENAME"
>kalamconfig</TT
> is not so interesting for
        this chapter, but it is available with the rest of the code.
        To summarize the development: all settings are now retrieved
        and set through a single pair of get/set functions. There are
        a lot more settings, too. If a setting requires special
        handling, then the relevant get/set function is retrieved from
        a dictionary (you can just as easily store references to
        functions or classes in a dictionary as in strings, since
        everything is considered an object) and executed with
        <TT
CLASS="FUNCTION"
>apply()</TT
>. If a setting is changed, a
        signal is emitted from the <TT
CLASS="CLASSNAME"
>QApplication</TT
>
        instance, which can be reached with the global variable
        <TT
CLASS="VARNAME"
>qApp</TT
>. Note how the actual signal identifier
        is constructed dynamically:</P
><PRE
CLASS="PROGRAMLISTING"
>#
# kalamconfig.py
# Get and set - set emits a signal via Config.notifier
#
customGetSetDictionary = {
    "style" : (getStyle, setStyle),
    "workspace" : (getWorkspace, setWorkspace),
    "textfont" : (getTextFont, setTextFont),
    "textforeground" : (getTextForegroundColor, setTextForegroundColor),
    "textbackground" : (getTextBackgroundColor, setTextBackgroundColor),
    "mdibackground" : (getMDIBackgroundColor, setMDIBackgroundColor),
}

def set(attribute, value):
    if customGetSetDictionary.has_key(attribute):
        apply(customGetSetDictionary[attribute][1], (value,))
    else:
        setattr(Config, attribute, value)
    qApp.emit(PYSIGNAL("sig" + str(attribute) + "Changed"),
                         (value,))

def get(attribute):
    if customGetSetDictionary.has_key(attribute):
        value = apply(customGetSetDictionary[attribute][0])
    else:
        value = getattr(Config, attribute)
    return value
      </PRE
><P
>But, let us continue with
        <TT
CLASS="FILENAME"
>dlgsettings.py</TT
>. There are three tab
        pages, and every tab pages has its own initialization function.</P
><PRE
CLASS="PROGRAMLISTING"
>    def initEditorTab(self):
        self.txtEditorPreview.setFont(self.textFont)

        pl = self.txtEditorPreview.palette()
        pl.setColor(QColorGroup.Base, self.textBackgroundColor)
        pl.setColor(QColorGroup.Text, self.textForegroundColor)
        
        self.cmbLineWrapping.setCurrentItem(kalamconfig.get("wrapmode"))
        self.spinLineWidth.setValue(kalamconfig.get("linewidth"))

        self.connect(self.bnBackgroundColor,
                     SIGNAL("clicked()"),
                     self.slotBackgroundColor)
        self.connect(self.bnForegroundColor,
                     SIGNAL("clicked()"),
                     self.slotForegroundColor)
        self.connect(self.bnFont,
                     SIGNAL("clicked()"),
                     self.slotFont)
      </PRE
><P
>The editor tab shows a nice preview of
        the font and color combination the user has chosen. Setting
        these colors, however, is not as straightforward as you might
        think. Qt widget colors are governed by a complex system based
        around palettes. A palette (<TT
CLASS="CLASSNAME"
>QPalette</TT
>)
        contains three color groups
        (<TT
CLASS="CLASSNAME"
>QColorGroup</TT
>), one that is used if the
        widget is active, one that is used if the widget is disabled,
        and one that is used if the widget is inactive.</P
><P
>A <TT
CLASS="CLASSNAME"
>QColorGroup</TT
> in its turn, is a set
      of colors with certain roles:</P
><P
></P
><UL
><LI
><P
>Background - general
            background color.</P
></LI
><LI
><P
>Foreground - general
            foreground color.</P
></LI
><LI
><P
>Base - background color text
            entry widgets
          </P
></LI
><LI
><P
>Text - the foreground color
            used with Base.</P
></LI
><LI
><P
>Button - general button
            background color</P
></LI
><LI
><P
>ButtonText - for button
            texts</P
></LI
><LI
><P
>Light - lighter than Button
            color. </P
></LI
><LI
><P
>Midlight - between Button
            and Light. </P
></LI
><LI
><P
>Dark - darker than Button.
          </P
></LI
><LI
><P
>Mid - between Button and
            Dark. </P
></LI
><LI
><P
>Shadow - a very dark color.
          </P
></LI
><LI
><P
>Highlight - a color to
            indicate a selected or highlighted item. </P
></LI
><LI
><P
>HighlightedText - a text
            color that contrasts to Highlight.</P
></LI
></UL
><P
>All colors are normally calculated from
        the Background color. Setting the background color of the
        editor with the convenience function
        <TT
CLASS="FUNCTION"
>setBackgroundColor()</TT
> won't have an
        effect; we must use the Base color in the relevant
        <TT
CLASS="CLASSNAME"
>QColorGroup</TT
>.</P
><P
>This system is certainly quite complex,
        but it allows for tremendous flexibility. Using it isn't too
        arduous. First, we retrieve the palette from the editor
        widget:</P
><PRE
CLASS="PROGRAMLISTING"
>        pl = self.txtEditorPreview.palette()
        pl.setColor(QColorGroup.Base, self.textBackgroundColor)
        pl.setColor(QColorGroup.Text, self.textForegroundColor)
      </PRE
><P
>Then we can use the function
        <TT
CLASS="FUNCTION"
>setColor</TT
>, which takes a colorgroup role
        and a <TT
CLASS="CLASSNAME"
>QColor</TT
> as arguments. Note that if
        we use these functions to change the colors of a widget after
        it has been shown for the first time, we must call
        <TT
CLASS="FUNCTION"
>repaint(TRUE)</TT
> to force the widget to
        redraw itself. Otherwise Qt's highly optimized drawing engine
        becomes confused. This will be done in the slot function
        that's connected to the <TT
CLASS="FUNCTION"
>clicked()</TT
> signal
        of the color choice buttons.</P
><PRE
CLASS="PROGRAMLISTING"
>    def initInterfaceTab(self):
        self.initStylesCombo()
        self.initWindowViewCombo()
        self.lblBackgroundColor.setBackgroundColor(self.MDIBackgroundColor)
        self.connect(self.bnWorkspaceBackgroundColor,
                     SIGNAL("clicked()"),
                     self.slotWorkspaceBackgroundColor)
      </PRE
><P
>The preview for the interface style is
        initialized in <TT
CLASS="FUNCTION"
>initWindowViewCombo</TT
>. Note
        that <TT
CLASS="CLASSNAME"
>QLabel</TT
> is rather more simple in
        its needs than <TT
CLASS="CLASSNAME"
>QMultiLineEdit</TT
> as
        regards colors. Here, you can just use the convenience
        function <TT
CLASS="FUNCTION"
>setBackgroundColor</TT
>
        (<TT
CLASS="FUNCTION"
>setEraseColor()</TT
> in Qt 3) to show the
        preview color for the MDI workspace.</P
><PRE
CLASS="PROGRAMLISTING"
>    def initDocumentTab(self):
        self.initEncodingCombo()
        self.chkAddNewLine.setChecked(kalamconfig.get("forcenewline"))
      </PRE
><P
>This must be the least complex tab, but
        no doubt we will be adding to it during the course of our
        development of <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
>.</P
><PRE
CLASS="PROGRAMLISTING"
>    def initStylesCombo(self):
        self.cmbStyle.clear()
        styles = kalamconfig.stylesDictionary.keys()
        styles.sort()
        try:
            currentIndex = styles.index(kalamconfig.Config.style)
        except:
            currentIndex = 0
            kalamconfig.setStyle(styles[0])
        self.cmbStyle.insertStrList(styles)
        self.cmbStyle.setCurrentItem(currentIndex)
        self.connect(self.cmbStyle,
                     SIGNAL("activated(const QString &#38;)"),
                     self.setStyle)
      </PRE
><P
>To make life a lot easer, we have
        defined a dictionary that maps user-understandable style names
        to <TT
CLASS="CLASSNAME"
>QStyle</TT
> classes in
        <TT
CLASS="FILENAME"
>kalamconfig</TT
>. Note that we need, in order
        to find out which one is the current style, not the result of
        <TT
CLASS="FUNCTION"
>kalamconfig.get("style")</TT
>, since that
        returns a <TT
CLASS="CLASSNAME"
>QStyle</TT
> object, but the actual
        string in the
        <TT
CLASS="CLASSNAME"
>Config</TT
><TT
CLASS="VARNAME"
>.style</TT
>
        variable.</P
><PRE
CLASS="PROGRAMLISTING"
># kalamconfig.py - styles dictionary
stylesDictionary = {
    "Mac OS 8.5" : QPlatinumStyle,
    "Windows 98" : QWindowsStyle,
    "Motif" : QMotifStyle,
    "Motif+" : QMotifPlusStyle,
    "CDE" : QCDEStyle
    }
      </PRE
><P
>The keys of this dictionary are used to
        fill the style combo. Python dictionaries are unordered, and
        to ensure that the same style is alwas at the same place in
        the combobox, we have to sort the list of keys. Sorting a list
        is done <SPAN
><I
CLASS="EMPHASIS"
>in place</I
></SPAN
> in Python, and that
        means that calling
        <TT
CLASS="FUNCTION"
>sort()</TT
> on a list doesn't return a list.
        If we'd written:</P
><PRE
CLASS="PROGRAMLISTING"
>        styles = kalamconfig.stylesDictionary.keys().sort()
      </PRE
><P
>instead, styles would have been set to
        <TT
CLASS="VARNAME"
>None</TT
>... Activating an entry in the styles
        combobox emits a signal that is routed to the
        <TT
CLASS="FUNCTION"
>setStyle()</TT
> function:</P
><PRE
CLASS="PROGRAMLISTING"
>    def setStyle(self, style):
        kalamconfig.set("style", str(style))
        qApp.setStyle(kalamconfig.get("style")())
      </PRE
><P
>Changing a style is instantaneous in
        <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
>, if only because it is fun to
        run through all the styles and see the
        application changing under your fingers. Therefore, we
        immediately update the style setting, and call
        <TT
CLASS="FUNCTION"
>qApp.setStyle()</TT
> to propagate the changes
        to the application widgets.</P
><PRE
CLASS="PROGRAMLISTING"
>    def initWindowViewCombo(self):
        self.cmbWindowView.clear()

        workspaces = kalamconfig.workspacesDictionary.keys()
        workspaces.sort()
        try:
            currentIndex = workspaces.index(kalamconfig.Config.workspace)
        except:
            currentIndex = 0
            kalamconfig.setWorkspace(workspaces[0])
        self.cmbWindowView.insertStrList(workspaces)
        self.cmbWindowView.setCurrentItem(currentIndex)

        self.connect(self.cmbWindowView,
                     SIGNAL("activated(const QString &#38;)"),
                     self.setWorkspacePreview)
      </PRE
><P
>Setting up the workspace selection
        combobox is similar to setting up the styles combobox. The
        only interesting point is the connection to
        <TT
CLASS="FUNCTION"
>setWorkspacePreview</TT
>. This function
        updates the small image that shows what each option means.
        These images were made from snapshots, and scaled down with
        Pixie, a KDE graphics application (which is now
        obsolete).</P
><PRE
CLASS="PROGRAMLISTING"
>    def setWorkspacePreview(self, workspace):
        workspace = str(workspace) + ".png"
        # XXX - when making installable, fix this path
        pixmap = QPixmap(os.path.join("./pixmaps",
                                      workspace))
        self.pxViewSample.setPixmap(pixmap)
      </PRE
><P
>As you can see, application development
        is messy, and I don't want to hide all the mess from you.
        Later, when we make the application distributable in <A href="index.lxp%3Flxpwrap=c8349.htm">Chapter 26</A
>, we
        will have to come back to this function and devise a way to
        make <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
> retrieve its pictures
        from the installation directory.</P
><PRE
CLASS="PROGRAMLISTING"
>    def initEncodingCombo(self):
        self.cmbEncoding.clear()
        encodings = kalamconfig.codecsDictionary.keys()
        encodings.sort()
        try:
            currentIndex = encodings.index(kalamconfig.get("encoding"))
        except:
            currentIndex = 0
            Config.encoding = encodings[0]

        self.cmbEncoding.insertStrList(encodings)
        self.cmbEncoding.setCurrentItem(currentIndex)
      </PRE
><P
>The list of encodings is defined in
        <TT
CLASS="FILENAME"
>kalamconfig</TT
>, just like the list of
        styles and interface types:</P
><PRE
CLASS="PROGRAMLISTING"
># kalamconfig.py - encodings dictionary

codecsDictionary = {
    "Unicode" : "utf8",
    "Ascii": "ascii",
    "West Europe (iso 8859-1)": "iso-8859-1",
    "East Europe (iso 8859-2)": "iso-8859-2",
    "South Europe (iso 8859-3)": "iso-8859-3",
    "North Europe (iso 8859-4)": "iso-8859-4",
    "Cyrilic (iso 8859-5)": "iso-8859-5",
    "Arabic (iso 8859-6)": "iso-8859-6",
    "Greek (iso 8859-7)": "iso-8859-7",
    "Hebrew (iso 8859-8)": "iso-8859-8",
    "Turkish (iso 8859-9)": "iso-8859-9",
    "Inuit (iso 8859-10)": "iso-8859-10",
    "Thai (iso 8859-11)": "iso-8859-11",
    "Baltic (iso 8859-13)": "iso-8859-13",
    "Gaeilic, Welsh (iso 8859-14)": "iso-8859-14",
    "iso 8859-15": "iso-8859-15",
    "Cyrillic (koi-8)": "koi8_r",
    "Korean (euc-kr)": "euc_kr"}
      </PRE
><P
>A <TT
CLASS="CLASSNAME"
>QMultiLineEdit</TT
> widget always used
        Unicode internally, but these codecs are used as a default
        setting for loading and saving files. Users load an
        ascii file, edit it in Unicode, and save it back to ascii.
        Theoretically, you can retrieve the users preferences from his
        locale. The operating system defines the preferred
        encoding, but people seldom work with one encoding, and
        <SPAN
CLASS="APPLICATION"
>Kalam</SPAN
> is meant to provide users with a
        choice.</P
><P
>While the selection of codecs in Python is large, not all
        important encodings are available from Python.
        Japanese (jis, shift-jis, euc-jp), Chinese (gbk) and Tamil
        (tscii) are only available in Qt (QTextCodec classes), and not in
        Python. Codecs for the tiscii encoding used for Devagari are
        not available anywhere. You can download separate Japanese
        codecs for Python from
        http://pseudo.grad.sccs.chukyo-u.ac.jp/~kajiyama/python/.
        (euc-jp, shift_jis, iso-2022-jp)</P
><P
> Note also that iso-8859-8 is visually ordered, and you
        need Qt 3.0 with the QHebrewCodec to translate iso-8859-8
        correctly to Unicode.</P
><PRE
CLASS="PROGRAMLISTING"
>    def slotForegroundColor(self):
        color = QColorDialog.getColor(self.textForegroundColor)
        if color.isValid():
            pl = self.txtEditorPreview.palette()
            pl.setColor(QColorGroup.Text, color)
            self.textForegroundColor = color
            self.txtEditorPreview.repaint(1)

    def slotBackgroundColor(self):
        color = QColorDialog.getColor(self.textBackgroundColor)
        if color.isValid():
            pl = self.txtEditorPreview.palette()
            pl.setColor(QColorGroup.Base, color)
            self.textBackgroundColor = color
            self.txtEditorPreview.repaint(1)

    def slotWorkspaceBackgroundColor(self):
        color = QColorDialog.getColor(self.MDIBackgroundColor)
        if color.isValid():
            self.MDIBackgroundColor = color
            self.lblBackgroundColor.setBackgroundColor(color)
      </PRE
><P
>Each of the color selection buttons is
        connected to one of these color slot functions. Note that
        <TT
CLASS="CLASSNAME"
>QFontDialog</TT
>, in contrast with
        <TT
CLASS="CLASSNAME"
>QColorDialog</TT
>, returns a tuple
        consisting of a <TT
CLASS="CLASSNAME"
>QFont</TT
> and a value that
        indicates whether the user pressed OK or Cancel.
        <TT
CLASS="CLASSNAME"
>QColorDialog</TT
> only returns a color; if
        the color is invalid, then the user pressed Cancel. This can
        be confusing, especially since an invalid
        <TT
CLASS="CLASSNAME"
>QColor</TT
> is just black. Note that we have
        to call <TT
CLASS="FUNCTION"
>repaint(1)</TT
>, here, to make sure
        the editor preview is updated.</P
><PRE
CLASS="PROGRAMLISTING"
>    def slotFont(self):
        (font, ok) = QFontDialog.getFont(kalamconfig.getTextFont(),
                                         self)
        if ok:
            self.txtEditorPreview.setFont(font)
            self.textFont = font
      </PRE
><P
>The <TT
CLASS="CLASSNAME"
>QFontDialog</TT
>
        <SPAN
><I
CLASS="EMPHASIS"
>does</I
></SPAN
> return a tuple&#8212;and if
        <TT
CLASS="VARNAME"
>ok</TT
> is true, then we update the font of the
        preview and also set the <TT
CLASS="VARNAME"
>textFont</TT
> variable
        to reflect the users choice.</P
><P
>Finally, there's a bit of code appended to
      <TT
CLASS="CLASSNAME"
>DlgSettings</TT
>, to make it possible to run
      the dialog on its own (to test all functionality):</P
><PRE
CLASS="PROGRAMLISTING"
>if __name__ == '__main__':
    a = QApplication(sys.argv)
    QObject.connect(a,SIGNAL('lastWindowClosed()'),a,SLOT('quit()'))
    w = DlgSettings()
    a.setMainWidget(w)
    w.show()
    a.exec_loop()
      </PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>Calling the settings dialog window</A
></H2
><P
>In order to be able to call the dialog window, we must
      first create a new <TT
CLASS="CLASSNAME"
>QAction</TT
> and add it to
      a likely menu. This is done in <TT
CLASS="CLASSNAME"
>KalamApp</TT
>:
      </P
><PRE
CLASS="PROGRAMLISTING"
># kalamapp.py
    def initActions(self):
        self.actions = {}
        ...
        #
        # Settings actions
        #

        self.actions["settingsSettings"] = QAction("Settings",
                                           "&#38;Settings",
                                           QAccel.stringToKey(""),
                                           self)
        self.connect(self.actions["settingsSettings"],
                     SIGNAL("activated()"),
                     self.slotSettingsSettings)
        ...

    def initMenuBar(self):
        ...
        self.settingsMenu = QPopupMenu()
        self.actions["settingsSettings"].addTo(self.settingsMenu)
        self.menuBar().insertItem("&#38;Settings", self.settingsMenu)
        ...
      </PRE
><P
>The <TT
CLASS="VARNAME"
>settingsSettings</TT
>
        is connected to a new slot in
        <TT
CLASS="CLASSNAME"
>KalamApp</TT
>:</P
><PRE
CLASS="PROGRAMLISTING"
>    # Settings slots

    def slotSettingsSettings(self):
        dlg = DlgSettings(self,
                          "Settings",
                          TRUE,
                          Qt.WStyle_Dialog)
      </PRE
><P
>The dialog window is constructed as a
        function-local variable. That means that if the function
        reaches its end, the <TT
CLASS="VARNAME"
>dlg</TT
> object is deleted.
        A settings dialog is typically modal. Whether a dialog is
        created modal or non-modal is determined in the constructor.
        The first argument to
        <TT
CLASS="FUNCTION"
>DlgSettings.__init__()</TT
> is the parent
        window, in this case <TT
CLASS="CLASSNAME"
>KalamApp</TT
>. The
        second argument is a name. The third argument determines
        whether the dialog is modal&#8212;TRUE means modal, FALSE
        means non-modal. FALSE is also the default. The last argument
        can be any combination of widget flags. For a dialog box,
        <TT
CLASS="VARNAME"
>Qt.WStyle_Dialog</TT
> seems rather appropriate.
        Note that in Qt 3, this flag is renamed to
        <TT
CLASS="VARNAME"
>Qt.WType_Dialog</TT
> There are a whole lot of
        flags (the following list is based on Qt 2 - there have been
        some changes):</P
><P
></P
><UL
><LI
><P
>WType_TopLevel - a toplevel
            window</P
></LI
><LI
><P
>WType_Modal - Makes the widget modal
            and inplies WStyle_Dialog. </P
></LI
><LI
><P
>WType_Popup - this widget is a popup
            top-level window, it is modal, but has a window system
            frame appropriate for popup menus. </P
></LI
><LI
><P
>WType_Desktop - This widget is the
            desktop - you can actually use PyQt to paint on you
            desktop.</P
></LI
><LI
><P
>WStyle_NormalBorder - The window has
            a normal border.</P
></LI
><LI
><P
>WStyle_DialogBorder - A thin dialog
            (if you windowmanager on X11 supports that).</P
></LI
><LI
><P
>WStyle_NoBorder - gives a borderless
            window. However, it is better to use WStyle_NoBorderEx
            instead, because this flag will make the window completely
            unusable on X11.
          </P
></LI
><LI
><P
>WStyle_NoBorderEx - gives a
            borderless window.</P
></LI
><LI
><P
>WStyle_Title - The window jas a
            title bar. </P
></LI
><LI
><P
>WStyle_SysMenu - adds a window
            system menu. </P
></LI
><LI
><P
>WStyle_Minimize - adds a minimize
            button. On Windows this must be combined with
            WStyle_SysMenu to work. </P
></LI
><LI
><P
>WStyle_Maximize - adds a maximize
            button. See WStyle_Minimize. </P
></LI
><LI
><P
>WStyle_MinMax - is equal to
            WStyle_Minimize|WStyle_Maximize. On Windows this must be
            combined with WStyle_SysMenu to work.
          </P
></LI
><LI
><P
>WStyle_ContextHelp - adds a context
            help button to dialogs. </P
></LI
><LI
><P
>WStyle_Tool - A tool window is a
            small window that contains tools (for instance, drawing
            tools, or the step buttons of a debugger). The tool window
            will always be kept on top of its parent, if there is
            one.</P
></LI
><LI
><P
>WStyle_StaysOnTop - the window
            should stay on top of all other windows. </P
></LI
><LI
><P
>WStyle_Dialog - indicates that the
            window is a dialog window. The window will not get its own
            taskbar entry and be kept on top of its parent by the
            window system. This is the flag QDialog uses, and it is
            not necessary for us to explicitly pass it to
            <TT
CLASS="CLASSNAME"
>DlgSettings</TT
>.
          </P
></LI
><LI
><P
>WDestructiveClose - makes Qt delete
            this object when the object has accepted closeEvent().
            Don't use this for dialog windows, or your application
            will crash.</P
></LI
><LI
><P
>WPaintDesktop - gives this widget
            paint events for the desktop. </P
></LI
><LI
><P
>WPaintUnclipped - makes all painters
            operating on this widget unclipped. Children of this
            widget, or other widgets in front of it, do not clip the
            area the painter can paint on. </P
></LI
><LI
><P
>WPaintClever - indicates that Qt
            should not try to optimize repainting for the widget, but
            instead pass the window system repaint events directly on
            to the widget.</P
></LI
><LI
><P
>WResizeNoErase - indicates that
            resizing the widget should not erase it. This allows
            smart-repainting to avoid flicker. </P
></LI
><LI
><P
>WMouseNoMask - indicates that even
            if the widget has a mask, it wants mouse events for its
            entire rectangle.
          </P
></LI
><LI
><P
>WNorthWestGravity - indicates that
            the widget contents are north-west aligned and static. On
            resize, such a widget will receive paint events only for
            the newly visible part of itself. </P
></LI
><LI
><P
>WRepaintNoErase - indicates that the
            widget paints all its pixels. Updating, scrolling and
            focus changes should therefore not erase the widget. This
            allows smart-repainting to avoid flicker. </P
></LI
><LI
><P
>WGroupLeader - makes this widget or
            window a group leader. Modality of secondary windows only
            affects windows within the same group. </P
></LI
></UL
><P
>You can combine these flags with the or
        (or |) operator. </P
><P
>Showing a modal dialog is a matter of
        simply calling <TT
CLASS="FUNCTION"
>exec_loop()</TT
>:
      </P
><PRE
CLASS="PROGRAMLISTING"
>        dlg.exec_loop()
        if dlg.result() == QDialog.Accepted:
            kalamconfig.set("textfont", dlg.textFont)
            kalamconfig.set("workspace", str(dlg.cmbWindowView.currentText()))
            kalamconfig.set("style", str(dlg.cmbStyle.currentText()))
            kalamconfig.set("textbackground", dlg.textBackgroundColor)
            kalamconfig.set("textforeground", dlg.textForegroundColor)
            kalamconfig.set("mdibackground", dlg.MDIBackgroundColor)
            kalamconfig.set("wrapmode", dlg.cmbLineWrapping.currentItem())
            kalamconfig.set("linewidth", int(str(dlg.spinLineWidth.text())))
            kalamconfig.set("encoding", str(dlg.cmbEncoding.currentText()))
            kalamconfig.set("forcenewline", dlg.chkAddNewLine.isChecked())
      </PRE
><P
>If the execution loop of a modal dialog
        terminates, the dialog object is not destroyed, and you can
        use the reference to the object to retrieve the contents of
        its widgets. By calling <TT
CLASS="FUNCTION"
>result()</TT
> on the
        dialog object you can determine whether the user pressed OK or
        Cancel.</P
><P
>In this example, if the user presses OK,
        all relevant settings in <TT
CLASS="FILENAME"
>kalamconfig</TT
> are
        updated. This causes <TT
CLASS="FILENAME"
>kalamconfig</TT
> to emit
        change signals that are caught by all relevant objects.</P
><P
>The <TT
CLASS="VARNAME"
>workspace</TT
> object
        is updated:</P
><PRE
CLASS="PROGRAMLISTING"
>    def initWorkSpace(self):
        workspace = kalamconfig.get("workspace")(self)
        workspace.setBackgroundColor(kalamconfig.get("mdibackground"))
        self.connect(qApp,
                     PYSIGNAL("sigmdibackgroundChanged"),
                     workspace.setBackgroundColor)
        self.setCentralWidget(workspace)
        return workspace
      </PRE
><P
>All <TT
CLASS="VARNAME"
>view</TT
> objects
        are updated, too. Some of the changes can be directly
        connected to the editor widget, the font setting, while others need
        a bit of processing, like the wrap mode:</P
><PRE
CLASS="PROGRAMLISTING"
># kalamview.py - extract
...
import kalamconfig
...
class KalamView(QWidget):

    def __init__(self, parent, doc, *args):
        ...
        self.editor.setFont(kalamconfig.get("textfont"))
        self.setWordWrap(kalamconfig.get("wrapmode"))
        self.setBackgroundColor(kalamconfig.get("textbackground"))
        self.setTextColor(kalamconfig.get("textforeground"))
        ...
        self.connect(qApp,
                     PYSIGNAL("siglinewidthChanged"),
                     self.editor.setWrapColumnOrWidth)
        self.connect(qApp,
                     PYSIGNAL("sigwrapmodeChanged"),
                     self.setWordWrap)
        self.connect(qApp,
                     PYSIGNAL("sigtextfontChanged"),
                     self.editor.setFont)
        self.connect(qApp,
                     PYSIGNAL("sigtextforegroundChanged"),
                     self.setTextColor)
        self.connect(qApp,
                     PYSIGNAL("sigtextbackgroundChanged"),
                     self.setBackgroundColor)
        ...

    def setTextColor(self, qcolor):
        pl = self.editor.palette()
        pl.setColor(QColorGroup.Text, qcolor)
        self.editor.repaint(TRUE)

    def setBackgroundColor(self, qcolor):
        pl = self.editor.palette()
        pl.setColor(QColorGroup.Base, qcolor)
        self.editor.setBackgroundColor(qcolor)        
        self.editor.repaint(TRUE)
        
    def setWordWrap(self, wrapmode):

        if wrapmode == 0:
            self.editor.setWordWrap(QMultiLineEdit.NoWrap)
        elif wrapmode == 1:
            self.editor.setWordWrap(QMultiLineEdit.WidgetWidth)
        else:
            self.editor.setWordWrap(QMultiLineEdit.FixedColumnWidth)
            self.editor.setWrapColumnOrWidth(kalamconfig.get("linewidth"))
    ...
      </PRE
><P
>Not all changes can be activated while the
        application is running. The workspace style is determined when
        the application is restarted. It is nice and courteous to
        inform the user so. The best place to do that is in
        <TT
CLASS="FUNCTION"
>slotSettingsSettings()</TT
>:</P
><PRE
CLASS="PROGRAMLISTING"
>    def slotSettingsSettings(self):
        ...
        if dlg.result() == QDialog.Accepted:
            ...
            workspace = str(dlg.cmbWindowView.currentText())
            if kalamconfig.Config.workspace &#60;&#62; workspace:
                kalamconfig.set("workspace", workspace)
                QMessageBox.information(self,
                                        "Kalam",
                                        "Changes to the interface style " +
                                        "will only be activated when you " +
                                        "restart the application.")
        ...
      </PRE
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A accesskey="P" href="index.lxp%3Flxpwrap=x6342.htm">Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="H" href="index.lxp%3Flxpwrap=book1.htm">Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A accesskey="N" href="index.lxp%3Flxpwrap=x6734.htm">Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Conclusion</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="U" href="index.lxp%3Flxpwrap=p4627.htm">Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Non-modal: Search and
      replace</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
      </td>
      </tr>
      </table>
      </td>
    </tr>
  </table>
  
    
