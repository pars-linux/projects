

  
  <table border="0" cellspacing="0" cellpadding="3" width="100%"><tr><td>
    <div align="center" id="bldcontent">
      <a href="http://www.opendocspublishing.com/"><img src="../images/opendocs.png" width="63" height="76" border="0"></a>
      <br>
      <div class="symbol">Your OpenSource Publisher&#153;</div>
    </div>
    
  </td></tr></table>
  
  <div align="center" class="author">
      	<a href="../products.lxp.html">Products</a>
	&nbsp;|&nbsp;
	<a href="../wheretobuy.lxp.html">Where to buy</a>
	&nbsp;|&nbsp;
	<a href="../bookstore.lxp.html">Retailers</a>
	&nbsp;|&nbsp;
	<a href="../FAQ.lxp.html">FAQ</a>
	&nbsp;|&nbsp;
        <a href="../writeforus.lxp.html">Write for Us.</a>
        &nbsp;|&nbsp;
        <a href="index.lxp%3Flxpwrap=x5388.htm#contact">Contact Us.</a>
  </div>
    <table border="0" cellspacing="3" cellpadding="0" width="100%"><tr><td width="100%">
      <div class="content">
        <table border="0" cellspacing="2" cellpadding="0" width="100%"><tr><td width="100%">
          <div align="center">
<H4 CLASS="AUTHOR"><A NAME="AEN5">Boudewijn Rempt</A>
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
<img src="ODPyQT125.png">
</a>
<br>
ISBN: 0-97003300-4-4
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
Available from bookstores everywhere or you can order it here.
</a>
<p>
You can download the source files for the book <a href="pyqtsrc.tgz">(code / eps) here.</a>
<hr>
</div>

          
          <HTML
><HEAD
><TITLE
>The Document Manager</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.72
"><LINK
REL="HOME"
TITLE="GUI Programming with Python: QT Edition"
HREF="book1.htm"><LINK
REL="UP"
TITLE="A More Complex Framework: Multiple Documents, Multiple
    Views"
HREF="c5288.htm"><LINK
REL="PREVIOUS"
TITLE="Document/View Manager"
HREF="x5339.htm"><LINK
REL="NEXT"
TITLE="Document"
HREF="x5451.htm"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GUI Programming with Python: QT Edition</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A accesskey="P" href="index.lxp%3Flxpwrap=x5339.htm">Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 15. A More Complex Framework: Multiple Documents, Multiple
    Views</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A accesskey="N" href="index.lxp%3Flxpwrap=x5451.htm">Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
>The Document Manager</A
></H1
><P
>The <TT
CLASS="CLASSNAME"
>DocManager</TT
>
      class is one of the more complex classes discussed in this book.
    </P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 15-2. The document manager class</B
></P
><PRE
CLASS="PROGRAMLISTING"
>"""
    docmanager.py &#8212; manager class for document/view mappings

copyright: (C) 2001, Boudewijn Rempt
email:     boud@rempt.xs4all.nl

"""

from qt import *

TRUE=1
FALSE=0


class DocManagerError(Exception):pass

class NoSuchDocumentError(DocManagerError):

    ERR = "Document %s with title %s is not managed by this DocumentManager"

    def __init__(self, document):
        self.errorMessage = ERR % (str(document), document.title(), str())

    def __repr__(self):
        return self.errorMessage

    def __str__(self):
        return self.errorMessage

class DocumentsRemainingError(DocManagerError):

    def __init__(self, document):
        self.errorMessage = "There are still documents remaining."

    def __repr__(self):
        return self.errorMessage

    def __str__(self):
        return self.errorMessage
    </PRE
></DIV
><P
>If you have a complex class like the
      document manager, it is often useful to create a few specific
      exception classes. You can still <TT
CLASS="FUNCTION"
>raise</TT
>
      exceptions that will be mere messages in a string &#8212; but
      these have been deprecated since Python 2.0. For the document
      manager we have a small hierarchy of exceptions, with a base
      exception (<TT
CLASS="CLASSNAME"
>DocManagerError</TT
>), and two
      specific exceptions, <TT
CLASS="CLASSNAME"
>NoSuchDocumentError</TT
>
      and <TT
CLASS="CLASSNAME"
>DocumentsRemainingError</TT
>. The first
      exception is raised when an attempt is made to delete a document
      which is not managed by the document manager. This can happen
      when you need more than one document manager, for instance. The
      second is raised when an attempt is made to delete all open
      documents, but one or more of them could not be closed.</P
><PRE
CLASS="PROGRAMLISTING"
>class DocManager(QObject):
    """
    The DocManager manages the creation and removal of documents
    and views.
    """
    def __init__(self, parent, viewManager = None):
        QObject.__init__(self)
        self._viewToDocMap = {}
        self._docToViewMap = {}
        self._parent=parent
        if viewManager:
            self._viewManager = viewManager
        else:
            self._viewManager = parent
    </PRE
><P
>Two very simple datastructures manage all
      the information in the document manage.  The first is
      <TT
CLASS="VARNAME"
>_viewToDocMap</TT
>, which maps documents to views
      (one document can be associated with a list of views). The other
      datastructure, <TT
CLASS="VARNAME"
>_docToViewMap</TT
>, maps views to
      documents. Note the single underscore before the variable names;
      this indicates that you shouldn't try to use the variable
      outside its class, in this case
      <TT
CLASS="CLASSNAME"
>DocManager</TT
>. The
      <TT
CLASS="VARNAME"
>viewManager</TT
> is the object that collects all
      views and shows them in the application letterbox between
      toolbars and statusbars.</P
><PRE
CLASS="PROGRAMLISTING"
>    def numberOfDocuments(self):
        return len(self._docToViewMap)

    def numberOfViews(self):
        return len(self._viewToDocMap)

    def views(self, document):
        return self._docToViewMap[document]

    def _createView(self, document, viewClass):
        view = viewClass(self._viewManager,
                         document,
                         None,
                         QWidget.WDestructiveClose)
        view.installEventFilter(self._parent)
        if self._viewToDocMap == {}:
            view.showMaximized()
        else:
            view.show()
        if self._docToViewMap.has_key(document):
            index = len(self._docToViewMap[document]) + 1
        else:
            index = 1
        view.setCaption(document.title() + " %s" % index)
        return view
    </PRE
><P
>The function <TT
CLASS="FUNCTION"
>_createView(self,
        document, viewClass)</TT
> not only maps views to
      documents, but also creates the view objects. Note the
      <TT
CLASS="VARNAME"
>QWidget.WDestructiveClose</TT
> flag &#8212; if
      this is not passed to the <TT
CLASS="CLASSNAME"
>QWidget</TT
>-derived
      view class, the view will not disappear from the screen when
      closed! If this view is the first, then it it will be maximized.
      This is one area where the docmanager still assumes a
      traditional MDI paradigm &#8212; we'll massage this out in the
      next chapter. Note also that we keep count of the number of
      views in each document, and then set the caption
      accordingly.</P
><P
>Note also that we &#8216;install' the event
      filter of the parent object &#8212; that is, the application
      &#8212; in the view. This overrides the default event handling
      of the view object, and makes it possible to use the document
      manager object.</P
><PRE
CLASS="PROGRAMLISTING"
>    def createDocument(self, documentClass, viewClass):
        document = documentClass()
        view = self._createView(document, viewClass)
        if self._docToViewMap.has_key(document):
            self._docToViewMap[document].append(view)
        else:
            self._docToViewMap[document] = [view]
        self._viewToDocMap[view] = document
        self.emit(PYSIGNAL("sigNumberOfDocsChanged"),())
        return document
    </PRE
><P
>The <TT
CLASS="FUNCTION"
>createDocument(self,
        documentClass, viewClass)</TT
> command actually
      instantiates the document. When that's done, a view is created
      and mapped to the document. Note the signal we emit here: it can
      be useful for the application object to know that the number of
      documents has been changed. For instance, the "save" menu option
      must be enabled when the first document is created.</P
><PRE
CLASS="PROGRAMLISTING"
>    def addView(self, document, viewClass):
        if self._docToViewMap.has_key(document):
            view = self._createView(document, viewClass)
            self._docToViewMap[document].append(view)
            self._viewToDocMap[view] = document
            return view
        else:
            raise DocManagerError(document)
    </PRE
><P
>Adding a new view to an existing document
      is fairly simple: just create the view and map it to a document,
      and vice versa. Note that if the document does not exist, we
      raise a <TT
CLASS="CLASSNAME"
>DocManagerError</TT
> &#8212; the
      document object apparently doesn't belong to this
      manager.</P
><PRE
CLASS="PROGRAMLISTING"
>    def addDocument(self, document, viewClass):
        view = self._createView(document, viewClass)
            
        if self._docToViewMap.has_key(document):
            self._docToViewMap[document].append(view)
        else:
            self._docToViewMap[document] = [view]
        self._viewToDocMap[view] = document
        self.emit(PYSIGNAL("sigNumberOfDocsChanged"),())
        return view
    </PRE
><P
>Of course, it must be possible to add an
      existing document to the document manager. This is used when the
      user opens a document.</P
><PRE
CLASS="PROGRAMLISTING"
>    def activeDocument(self):
        if self._viewManager.activeWindow() is not None:
            return self._viewToDocMap[self._viewManager.activeWindow()]
        else:
            return None
    </PRE
><P
>Since the
      <TT
CLASS="CLASSNAME"
>QWorkSpace</TT
> class, which is the model for
      the view manager, knows which window is active, we can use that
      to determine which document is active.</P
><PRE
CLASS="PROGRAMLISTING"
>    def _saveDocument(self, document):
        if document.pathName() == None:
            document.setPathName(self._parent.queryFileName(document))
        try:
            document.save()
        except Exception, e:
            QMessageBox.critical(self,
                                 "Error",
                                 "Could not save the current document: " + e)
            raise e
    </PRE
><P
>The things that can go wrong when trying
      to save a document are manifold &#8212; however, we assume that
      the document knows when to shout "Exception". If that happens,
      the user is informed, and the exception re-raised.</P
><PRE
CLASS="PROGRAMLISTING"
>    def _queryCloseDocument(self, document):
        if self._parent.queryCloseDocument(document) == QMessageBox.No:
            return FALSE
        if document.modified():
            save = self._parent.querySaveDocument(document)
            if save == QMessageBox.Yes:
                try:
                    self._saveDocument(document)
                    return TRUE
                except Exception, e:
                    if self._parent.queryDiscardDocument(document) &#60;&#62; \
                       QMessageBox.Yes:
                        return FALSE
                    else:
                        return TRUE
            elif save == QMessageBox.No:
                return TRUE
            elif save == QMessageBox.Cancel:
                return FALSE
        return TRUE
    </PRE
><P
>The aim of
      <TT
CLASS="FUNCTION"
>_queryCloseDocument</TT
> is to determine what
      the user really wants when he closes a document&#8212;an action
      that can throw quite a few wobblies. At every step the function
      asks the user what he wants. Does he want to save the data? And
      in case saving doesn't succeed, does he want to discard the
      document? Or would he prefer to keep the document open, and go
      on throwing foul looks at an application that contains his
      precious data, which he cannot save? </P
><PRE
CLASS="PROGRAMLISTING"
>    def _removeView(self, view, document):
        try:
            self._docToViewMap[document].remove(view)
            del self._viewToDocMap[view]
        except ValueError, e:
            pass # apparently already deleted

    def closeView(self, view):
        document=self._viewToDocMap[view]
        if len(self._docToViewMap[document])==1:
            if self._queryCloseDocument(document):
                self._removeView(view, document)
                del self._docToViewMap[document]
                return TRUE
            else:
                return FALSE
        else:
            self._removeView(view, document)
            return TRUE

    def closeDocument(self, document):
        l=self._docToViewMap[document][:]
        for view in l:
            if view.close(TRUE) == FALSE:
                return FALSE
        self.emit(PYSIGNAL("sigNumberOfDocsChanged"),())
        return TRUE

    def closeAllDocuments(self):
        for document in self._docToViewMap.keys():
            if not self.closeDocument(document):
                raise DocumentsRemainingError()
    </PRE
><P
>Getting rid of documents and views can
      become quite complicated if you take into consideration all the
      various methods available: a user can click on the close button
      in the titlebar of the application, or in the view, or activate
      the "close" <TT
CLASS="CLASSNAME"
>QAction</TT
>. In order to catch
      the first possibility, we need to use event filters. Clicking on
      the close button does not generate a signal we can connect to.
      That being so, we should only call <TT
CLASS="FUNCTION"
>close()</TT
>
      on the view, if we know that the closing has
      <SPAN
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> been initiated through the event filter
      (otherwise we would fire the event filter again).</P
><P
>However, when the user selects "close
      document" or "close all documents" from the menu or the toolbar,
      <TT
CLASS="FUNCTION"
>close()</TT
> will not be automatically called on
      the view &#8212; we have to do this ourselves. By looping
      through all views in the document, and closing them, we will
      generate an event: the event will be handled by the event
      filter, which will call <TT
CLASS="FUNCTION"
>closeView()</TT
> for us.
      And <TT
CLASS="FUNCTION"
>closeView()</TT
> will ask the user whether
      it really wants to close the document if the view is the last
      one.</P
><P
>It's an interesting exercise to follow
      this happening with the BlackAdder debugger.</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A accesskey="P" href="index.lxp%3Flxpwrap=x5339.htm">Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="H" href="index.lxp%3Flxpwrap=book1.htm">Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A accesskey="N" href="index.lxp%3Flxpwrap=x5451.htm">Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Document/View Manager</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="U" href="index.lxp%3Flxpwrap=c5288.htm">Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Document</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
      </td>
      </tr>
      </table>
      </td>
    </tr>
  </table>
  
    
