

  
  <table border="0" cellspacing="0" cellpadding="3" width="100%"><tr><td>
    <div align="center" id="bldcontent">
      <a href="http://www.opendocspublishing.com/"><img src="../images/opendocs.png" width="63" height="76" border="0"></a>
      <br>
      <div class="symbol">Your OpenSource Publisher&#153;</div>
    </div>
    
  </td></tr></table>
  
  <div align="center" class="author">
      	<a href="../products.lxp.html">Products</a>
	&nbsp;|&nbsp;
	<a href="../wheretobuy.lxp.html">Where to buy</a>
	&nbsp;|&nbsp;
	<a href="../bookstore.lxp.html">Retailers</a>
	&nbsp;|&nbsp;
	<a href="../FAQ.lxp.html">FAQ</a>
	&nbsp;|&nbsp;
        <a href="../writeforus.lxp.html">Write for Us.</a>
        &nbsp;|&nbsp;
        <a href="index.lxp%3Flxpwrap=x2104.htm#contact">Contact Us.</a>
  </div>
    <table border="0" cellspacing="3" cellpadding="0" width="100%"><tr><td width="100%">
      <div class="content">
        <table border="0" cellspacing="2" cellpadding="0" width="100%"><tr><td width="100%">
          <div align="center">
<H4 CLASS="AUTHOR"><A NAME="AEN5">Boudewijn Rempt</A>
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
<img src="ODPyQT125.png">
</a>
<br>
ISBN: 0-97003300-4-4
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
Available from bookstores everywhere or you can order it here.
</a>
<p>
You can download the source files for the book <a href="pyqtsrc.tgz">(code / eps) here.</a>
<hr>
</div>

          
          <HTML
><HEAD
><TITLE
>QCString &#8212; simple strings in PyQt</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.72
"><LINK
REL="HOME"
TITLE="GUI Programming with Python: QT Edition"
HREF="book1.htm"><LINK
REL="UP"
TITLE="String Objects in Python and Qt"
HREF="c2029.htm"><LINK
REL="PREVIOUS"
TITLE="String conversions"
HREF="x2068.htm"><LINK
REL="NEXT"
TITLE="Unicode strings"
HREF="x2183.htm"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GUI Programming with Python: QT Edition</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A accesskey="P" href="index.lxp%3Flxpwrap=x2068.htm">Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 8. String Objects in Python and Qt</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A accesskey="N" href="index.lxp%3Flxpwrap=x2183.htm">Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
>QCString &#8212; simple strings in PyQt</A
></H1
><P
>Both Python and Qt have two types of
      strings: simple strings, which are sequences of bytes where
      every byte represents one character, and complex string objects,
      which contain characters in the Unicode encoding. Unicode is a
      complex topic that is treated in the next section; this section
      deals with simple strings.</P
><P
><TT
CLASS="CLASSNAME"
>QCString</TT
> is the PyQt
      equivalent of the Python simple string. The Qt documentation
      describes <TT
CLASS="CLASSNAME"
>QCString</TT
> as a weak class, which
      is accurate. The implementation does not feature all the
      intelligence and care that has gone into
      <TT
CLASS="CLASSNAME"
>QString</TT
>, and as a consequence it scales
      poorly to large strings.</P
><P
>As an abstraction of the standard C++
      null-terminated string, <TT
CLASS="CLASSNAME"
>QCString</TT
> cannot
      contain any null bytes ('\0'). In this respect,
      <TT
CLASS="CLASSNAME"
>QCString</TT
> differs from the simple Python
      string object. The simple Python string is often used as a
      container for binary data, and the string object doesn't care
      whether it contains null bytes. Feeding a Python string that
      contains null bytes to a QCString provides interesting results:
      </P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 8-3. empty.py - feeding zero bytes to a QCString</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#
# empty.py - feeding zero bytes to a QCString
#

from qt import *

pystring='abc\0def'
print "Python string:", pystring
print "Length:", len(pystring)

qcstring=QCString(pystring)
print "QCString:", qcstring
print "Length:", qcstring.length()
      </PRE
></DIV
><P
>Running the previous example produces the following
      output:</P
><PRE
CLASS="SCREEN"
>boudewijn@maldar:~/doc/opendoc/ch4 &#62; python empty.py
Python string: abcdef
Length: 7
QCString: abc
Length: 3
    </PRE
><P
>Except for this proviso, both
      <TT
CLASS="CLASSNAME"
>QCString</TT
> and the Python string object are
      equivalent, and you can use the Python string object wherever a
      <TT
CLASS="CLASSNAME"
>QCString</TT
> is needed as a parameter in a
      function. You can convert the <TT
CLASS="CLASSNAME"
>QCString</TT
>
      back to a python string with the <TT
CLASS="FUNCTION"
>str()</TT
>
      function. If the <TT
CLASS="CLASSNAME"
>QCString</TT
> is
      <SPAN
><I
CLASS="EMPHASIS"
>empty</I
></SPAN
>, i.e., it contains only one byte with
      the value <SPAN
><I
CLASS="EMPHASIS"
>zero</I
></SPAN
> ('\0'), an empty Python
      string is returned, <SPAN
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> a Python string
      that contains one zero byte.</P
><P
>The issue of null versus empty strings is an
      interesting one. A null <TT
CLASS="CLASSNAME"
>QCString</TT
> is
      constructed as follows:</P
><PRE
CLASS="PROGRAMLISTING"
>nullstring=QCString()</PRE
><P
>This string is conceptually equivalent to
      the Python <TT
CLASS="CLASSNAME"
>None</TT
> object, except that the
      null <TT
CLASS="CLASSNAME"
>QCString</TT
> has a type. There is no way
      to construct a <SPAN
><I
CLASS="EMPHASIS"
>null</I
></SPAN
> Python string: a Python
      string without contents is always <SPAN
><I
CLASS="EMPHASIS"
>empty</I
></SPAN
>,
      i.e. the equivalent of a <TT
CLASS="CLASSNAME"
>QCString</TT
> that
      contains one byte with the value <SPAN
><I
CLASS="EMPHASIS"
>zero</I
></SPAN
>. The
      following script attempts a few combinations, using Python's
      built-in <TT
CLASS="FUNCTION"
>assert</TT
> function.
      </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>Assert: </B
>The <TT
CLASS="FUNCTION"
>assert</TT
> statement
        is one of the more useful tools in the Python developers
        toolchest. You can use <TT
CLASS="FUNCTION"
>assert</TT
> to check
        any statement for truth &#8212; and if it fails, an
        AssertionException is thrown. If you compile your Python
        scripts to optimized bytecode (.pyo files), then the assertion
        statements are removed, making <TT
CLASS="FUNCTION"
>assert</TT
>
        ideal for checking your code for invalid entry conditions in
        method calls during development. The use of
        <TT
CLASS="FUNCTION"
>assert</TT
> in the following script is more of
        a hack: this little script wouldn't do anything if run with
        python -O null.py; only the line print message, "TRUE" would
        be executed in the <TT
CLASS="FUNCTION"
>assertTrue</TT
>
        function.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 8-4. null.py - empty and null QCStrings and Python
        strings</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#
# null.py - empty and null QCStrings and Python strings
#
from qt import QCString

# this string is empty
emptypystring=""

# this string contains one byte, zero
nullpystring="\0"

# this string is empty: it contains the empty string, terminated with \0
emptyqcstring=QCString("")

# this string is null: it doesn't contain data
nullqcstring=QCString()

def assertTrue(assertion, message):
    try:
        assert(assertion)
        print message, "TRUE"
    except AssertionError:
        print message, "FALSE"

assertTrue(emptypystring==emptyqcstring,
    "Empty Python string equals empty QCString")
assertTrue(emptypystring==str(emptyqcstring),
    "Empty Python string equals str(empty QCString)")
assertTrue(emptypystring==str(nullqcstring),
    "Empty python string equals str(null QCString)")
assertTrue(nullpystring==emptyqcstring,
    "Python string containing 0 byte equals empty QCString")
assertTrue(nullpystring==str(emptyqcstring),
    "Python string containing 0 byte equals str(empty QCSTRING)")
assertTrue(nullqcstring is None,
    "Null QCString equals None object")
      </PRE
></DIV
><P
>Running this gives the following output:</P
><PRE
CLASS="SCREEN"
>boudewijn@maldar:~/doc/opendoc/ch4 &#62; python null.py
Empty Python string equals empty QCString FALSE
Empty Python string equals str(empty QCString) TRUE
Empty python string equals str(null QCString) TRUE
Python string containing 0 byte equals empty QCString FALSE
Python string containing 0 byte equals str(empty QCSTRING) FALSE
Null QCString equals None object FALSE
    </PRE
><P
>Of course, some of these concerns hold for
      <TT
CLASS="CLASSNAME"
>QString</TT
>, too. It is equally possible to
      have an empty <TT
CLASS="CLASSNAME"
>QString</TT
> or a null
      <TT
CLASS="CLASSNAME"
>QString</TT
>. Note that embedding a zero byte
      in a Python string and then feeding it to a
      <TT
CLASS="CLASSNAME"
>QString</TT
> shows the same behavior as with
      <TT
CLASS="CLASSNAME"
>QCString</TT
>, even though
      <TT
CLASS="CLASSNAME"
>QString</TT
> isn't a null-terminated string
      class:</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 8-5. emptyqstring.py - feeding zero bytes to a
        QString</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#
# emptyqstring.py - feeding zero bytes to a QString
#

from qt import *

pystring='abc\0def'
print "Python string:", pystring
print "Length:", len(pystring)

qstring=QString(pystring)
print "QString:", qstring
print "Length:", qstring.length()
      </PRE
></DIV
><P
>Look at the output:</P
><PRE
CLASS="SCREEN"
>boudewijn@maldar:~/doc/opendoc/ch4 &#62; python emptyqstring.py
Python string: abcdef
Length: 7
QString: abc
Length: 3
    </PRE
><P
>The unavoidable conclusion is that you
      shouldn't try to use Python strings as containers for binary
      data and then convert them to Qt string objects. Of course,
      there's a solution: you can use
      <TT
CLASS="CLASSNAME"
>QByteArray</TT
> to store binary data.</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A accesskey="P" href="index.lxp%3Flxpwrap=x2068.htm">Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="H" href="index.lxp%3Flxpwrap=book1.htm">Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A accesskey="N" href="index.lxp%3Flxpwrap=x2183.htm">Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>String conversions</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="U" href="index.lxp%3Flxpwrap=c2029.htm">Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Unicode strings</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
      </td>
      </tr>
      </table>
      </td>
    </tr>
  </table>
  
    
