

  
  <table border="0" cellspacing="0" cellpadding="3" width="100%"><tr><td>
    <div align="center" id="bldcontent">
      <a href="http://www.opendocspublishing.com/"><img src="../images/opendocs.png" width="63" height="76" border="0"></a>
      <br>
      <div class="symbol">Your OpenSource Publisher&#153;</div>
    </div>
    
  </td></tr></table>
  
  <div align="center" class="author">
      	<a href="../products.lxp.html">Products</a>
	&nbsp;|&nbsp;
	<a href="../wheretobuy.lxp.html">Where to buy</a>
	&nbsp;|&nbsp;
	<a href="../bookstore.lxp.html">Retailers</a>
	&nbsp;|&nbsp;
	<a href="../FAQ.lxp.html">FAQ</a>
	&nbsp;|&nbsp;
        <a href="../writeforus.lxp.html">Write for Us.</a>
        &nbsp;|&nbsp;
        <a href="index.lxp%3Flxpwrap=x5255.htm#contact">Contact Us.</a>
  </div>
    <table border="0" cellspacing="3" cellpadding="0" width="100%"><tr><td width="100%">
      <div class="content">
        <table border="0" cellspacing="2" cellpadding="0" width="100%"><tr><td width="100%">
          <div align="center">
<H4 CLASS="AUTHOR"><A NAME="AEN5">Boudewijn Rempt</A>
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
<img src="ODPyQT125.png">
</a>
<br>
ISBN: 0-97003300-4-4
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
Available from bookstores everywhere or you can order it here.
</a>
<p>
You can download the source files for the book <a href="pyqtsrc.tgz">(code / eps) here.</a>
<hr>
</div>

          
          <HTML
><HEAD
><TITLE
>Testing signals and slots</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.72
"><LINK
REL="HOME"
TITLE="GUI Programming with Python: QT Edition"
HREF="book1.htm"><LINK
REL="UP"
TITLE="Automatic testing with PyUnit"
HREF="c5064.htm"><LINK
REL="PREVIOUS"
TITLE="Large projects"
HREF="x5234.htm"><LINK
REL="NEXT"
TITLE="Conclusion"
HREF="x5285.htm"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GUI Programming with Python: QT Edition</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A accesskey="P" href="index.lxp%3Flxpwrap=x5234.htm">Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 14. Automatic testing with PyUnit</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A accesskey="N" href="index.lxp%3Flxpwrap=x5285.htm">Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
>Testing signals and slots</A
></H1
><P
>It's quite difficult to work the signals
      and slots mechanism into the unittest framework. This is not
      surprising, since signals and slots quintessentially join
      components together, and the unittests are meant to test each
      component separately.</P
><P
>However, you might want to test whether
      calling a method on a certain object causes it to emit the right
      signals. We need a bit of a custom framework for that purpose, a
      kind of signal test.</P
><P
>You can use the
      <TT
CLASS="CLASSNAME"
>ConnectionBox</TT
> from the following script
      for that purpose. It is a simple class, derived from
      <TT
CLASS="CLASSNAME"
>QObject</TT
>, which has one slot,
      <TT
CLASS="FUNCTION"
>slotSlot()</TT
>, that can be connected to a
      signal with any number of arguments.</P
><P
>The arguments to the signal are stored in
      the <TT
CLASS="CLASSNAME"
>ConnectionBox</TT
>, so they can be checked
      later using the various assertion functions.</P
><P
>I have provided three assertion functions,
      one to check whether the signal did arrive
      (<TT
CLASS="FUNCTION"
>assertSignalArrived</TT
>), one to check whether
      the number of arguments was right,
      (<TT
CLASS="FUNCTION"
>assertNumberOfArguments</TT
>), and one to check
      the types of the arguments using the Python
      <TT
CLASS="FILENAME"
>types</TT
>
      (<TT
CLASS="FUNCTION"
>assertArgumentTypes</TT
>). This provides
      typenames for all built-in types, but objects created from all
      user-defined classes (including PyQt classes), belong to the
      <TT
CLASS="VARNAME"
>InstanceType</TT
>. This means that you cannot
      check whether you got a <TT
CLASS="CLASSNAME"
>QListViewItem</TT
> or
      a <TT
CLASS="CLASSNAME"
>QListView</TT
> from a PyQt signal using this
      function.</P
><P
>It would be a nice exercise to extend this
      assert with checking objects using the
      <TT
CLASS="CLASSNAME"
>QObject</TT
>.<TT
CLASS="FUNCTION"
>className()</TT
>
      method. Feel free...</P
><PRE
CLASS="PROGRAMLISTING"
>#
# signals.py - unit-testing signals
#
import sys
import unittest
import types
from docviewdoc import DocviewDoc
from qt import *

class ConnectionBox(QObject):

    def __init__(self, *args):
        apply(QObject.__init__,(self,)+args)
        self.signalArrived=0
        self.args=[]

    def slotSlot(self, *args):
        self.signalArrived=1
        self.args=args

    def assertSignalArrived(self, signal=None):
        if  not self.signalArrived:
            raise AssertionError, ("signal %s did not arrive" % signal)

    def assertNumberOfArguments(self, number):
        if number &#60;&#62; len(self.args):
            raise AssertionError, \
                  ("Signal generated %i arguments, but %i were expected" %
                                    (len(self.args), number))

    def assertArgumentTypes(self, *args):
        if len(args) &#60;&#62; len(self.args):
            raise AssertionError, \
         ("Signal generated %i arguments, but %i were given to this function" %
                                 (len(self.args), len(args)))
        for i in range(len(args)):
            if type(self.args[i]) != args[i]:
                raise AssertionError, \
                      ( "Arguments don't match: %s received, should be %s." %
                                      (type(self.args[i]), args[i]))

class SignalsTestCase(unittest.TestCase):
    """This testcase tests the testing of signals
    """
    def setUp(self):
        self.doc=DocviewDoc()
        self.connectionBox=ConnectionBox()
        
    def tearaDown(self):
        self.doc.disConnect()
        self.doc=None
        self.connectionBox=None
        
    def checkSignalDoesArrive(self):
        """Check whether the sigDocModified signal arrives"""
        self.connectionBox.connect(self.doc, PYSIGNAL("sigDocModified"),
                              self.connectionBox.slotSlot)
        self.doc.slotModify()
        self.connectionBox.assertSignalArrived("sigDocModified")

    def checkSignalDoesNotArrive(self):
        """Check whether the sigDocModifiedXXX signal does not arrive"""
        self.connectionBox.connect(self.doc, PYSIGNAL("sigDocModifiedXXX"),
                                   self.connectionBox.slotSlot)
        self.doc.slotModify()
        try:
            self.connectionBox.assertSignalArrived("sigDocModifiedXXX")
        except AssertionError:
            pass
        else:
            fail("The signal _did_ arrive")

    def checkArgumentToSignal(self):
        """Check whether the sigDocModified signal has the right
           number of arguments
        """
        self.connectionBox.connect(self.doc, PYSIGNAL("sigDocModified"),
                                   self.connectionBox.slotSlot)
        self.doc.slotModify()
        self.connectionBox.assertNumberOfArguments(1)

    def checkArgumentTypes(self):
        """Check whether the sigDocModified signal has the right 
           type of arguments.
        """
        self.connectionBox.connect(self.doc, PYSIGNAL("sigDocModified"),
                                   self.connectionBox.slotSlot)
        self.doc.slotModify()
        self.connectionBox.assertArgumentTypes(types.IntType)


def suite():
    testSuite=unittest.makeSuite(SignalsTestCase, "check")
    return testSuite


def main():
    runner = unittest.TextTestRunner()
    runner.run(suite())

if __name__=="__main__":
    main()
    </PRE
><P
>Using this
      <TT
CLASS="CLASSNAME"
>ConnectionBox</TT
>, you can test your
      signals:</P
><PRE
CLASS="SCREEN"
>boud@calcifer:~/doc/pyqt/ch9 &#62; python signals.py
Check whether the sigDocModified signal has the right number arguments ... ok
Check whether the sigDocModified signal has the right type of arguments ... ok
Check whether the sigDocModified signal arrives ... ok
Check whether the sigDocModifiedXXX signal does not arrive ... ok
------------------------------------------------------------------------------
Ran 4 tests in 0.003s

OK
    </PRE
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A accesskey="P" href="index.lxp%3Flxpwrap=x5234.htm">Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="H" href="index.lxp%3Flxpwrap=book1.htm">Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A accesskey="N" href="index.lxp%3Flxpwrap=x5285.htm">Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Large projects</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="U" href="index.lxp%3Flxpwrap=c5064.htm">Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Conclusion</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
      </td>
      </tr>
      </table>
      </td>
    </tr>
  </table>
  
    
