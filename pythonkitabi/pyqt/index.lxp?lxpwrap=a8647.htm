

  
  <table border="0" cellspacing="0" cellpadding="3" width="100%"><tr><td>
    <div align="center" id="bldcontent">
      <a href="http://www.opendocspublishing.com/"><img src="../images/opendocs.png" width="63" height="76" border="0"></a>
      <br>
      <div class="symbol">Your OpenSource Publisher&#153;</div>
    </div>
    
  </td></tr></table>
  
  <div align="center" class="author">
      	<a href="../products.lxp.html">Products</a>
	&nbsp;|&nbsp;
	<a href="../wheretobuy.lxp.html">Where to buy</a>
	&nbsp;|&nbsp;
	<a href="../bookstore.lxp.html">Retailers</a>
	&nbsp;|&nbsp;
	<a href="../FAQ.lxp.html">FAQ</a>
	&nbsp;|&nbsp;
        <a href="../writeforus.lxp.html">Write for Us.</a>
        &nbsp;|&nbsp;
        <a href="index.lxp%3Flxpwrap=a8647.htm#contact">Contact Us.</a>
  </div>
    <table border="0" cellspacing="3" cellpadding="0" width="100%"><tr><td width="100%">
      <div class="content">
        <table border="0" cellspacing="2" cellpadding="0" width="100%"><tr><td width="100%">
          <div align="center">
<H4 CLASS="AUTHOR"><A NAME="AEN5">Boudewijn Rempt</A>
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
<img src="ODPyQT125.png">
</a>
<br>
ISBN: 0-97003300-4-4
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
Available from bookstores everywhere or you can order it here.
</a>
<p>
You can download the source files for the book <a href="pyqtsrc.tgz">(code / eps) here.</a>
<hr>
</div>

          
          <HTML
><HEAD
><TITLE
>Reading the Qt Documentation</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.72
"><LINK
REL="HOME"
TITLE="GUI Programming with Python: QT Edition"
HREF="book1.htm"><LINK
REL="UP"
TITLE="Appendices"
HREF="p8645.htm"><LINK
REL="PREVIOUS"
TITLE="Appendices"
HREF="p8645.htm"><LINK
REL="NEXT"
TITLE="PyQwt: Python Bindings for Qwt"
HREF="a8743.htm"></HEAD
><BODY
CLASS="APPENDIX"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GUI Programming with Python: QT Edition</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A accesskey="P" href="index.lxp%3Flxpwrap=p8645.htm">Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A accesskey="N" href="index.lxp%3Flxpwrap=a8743.htm">Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="APPENDIX"
><H1
>Appendix A. Reading the Qt Documentation</A
></H1
><P
>Qt is originally a C++ GUI toolkit,
    and PyQt is just a wrapper around it. Fortunately, Qt is very well
    designed and makes full use of the object-oriented qualities of
    C++, so the translation is very comfortable, and PyQt feel like a
    real Python library.</P
><P
>BlackAdder includes a copy of the Qt
    class documentation (nineteen megabytes of html text) that has
    been fully translated to Python. Of course, if you want to use a
    more recent version of PyQt than that which comes with BlackAdder,
    or if you use PyQt on itself, then you need to read the C++
    documentation for all the details that I didn't have space to
    discuss in this book. After all, this book teaches you how to use
    the toolkit to create complete applications, and isn't a mere
    duplication of the class documentation.</P
><P
>Fortunately, reading C++
    documentation for use from Python isn't very difficult. In fact,
    the translation to Python idiom that is included with BlackAdder
    has been achieved for the greater part with a few find &#38; replace
    scripts. However, if your knowledge of C++ (or C) is limited to
    knowing that it exists, then you might want to read this appendix
    for some guidance.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Using KDE to have quick access to the Qt
      documentation: </B
>If you are using KDE on Unix/X11,
      you can create new internet shortcuts that take you to the Qt
      class documentation in an instant.</P
><P
>KDE has a wonderful feature,
      called the run command window, in which you can type a short
      abbreviation (like  "gg" for the Google search engine), followed
      by a colon and an argument.</P
><P
>If you add
      "file://usr/lib/qt2/doc/html/\1.html" in
      <SPAN
CLASS="APPLICATION"
>KControl</SPAN
>, section Web
      Browsing/Enhanced Browsing:</P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>Creating a shortcut
            to the Qt documentation</P
></DIV
></P
></DIV
><P
>Then you will be able to access al
      Qt documentation by typing "qt:qobject", for instance. What you
      are typing is the name of the html document that contains the
      class information: all these documents have the classname as a
      filename, all in lowercase.</P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>Using a shortcut to
            the Qt documentation</P
></DIV
></P
></DIV
><P
>Note that the shortcut
      (file://usr/lib/qt2/doc/html/\1.html) should point to the place
      where your qt (or BlackAdder - that would work too)
      documentation resides. The element after the directory path
      (\1.html) is a simple substitution argument&#8212; \1 is
      replaced by what you type after the colon.</P
><P
>You can quickly access the run
      command window by pressing ALT-F2 in KDE's standard
      configuration.</P
></BLOCKQUOTE
></DIV
><P
>Let's take a simple Qt class as an
    example: <TT
CLASS="CLASSNAME"
>QLabel</TT
>. It's a good idea to open
    the Qt class documentation in your browser window (remember the
    KDE shortcut) and keep that in view.</P
><P
>First, the documentation tells you
    that the <TT
CLASS="CLASSNAME"
>QLabel</TT
> class includes
    <TT
CLASS="FILENAME"
>qlabel.h</TT
>: <SPAN
><I
CLASS="EMPHASIS"
>#include
      &#60;qlabel.h&#62;</I
></SPAN
>. This means about the same as a
    Python import statement. You can disregard it.</P
><P
>The methods that do not return
    anything, but have the same name as the class, are the C++
    constructors. Simply call them with the right arguments. Don't pay
    attention to any spurious asterisks (*) or ampersands (&#38;) around
    the arguments to the function: what matters is the type, like
    <TT
CLASS="CLASSNAME"
>QWidget</TT
>. Don't pay attention to the
    <TT
CLASS="VARNAME"
>const</TT
> keyword either.</P
><P
>If there is an equals sign (=)
    after the variable name, then the function can use a default
    parameter, just like in Python. Again, just like in Python,
    booleans are zero or one. However, a default
    argument of zero, has a default argument of None in Python. This
    is important if you want to use two out of three arguments: then
    you must also mention the middle man (you can safely drop any
    tailing default arguments you don't need):</P
><PRE
CLASS="PROGRAMLISTING"
>label=QLabel("text", None, "name")
  </PRE
><P
>versus</P
><PRE
CLASS="PROGRAMLISTING"
>label=QLabel("text")
  </PRE
><P
>Public members are instance methods
    of objects. If you call a public member, you should always prefix
    the call with the name of the object you have created (or
    <TT
CLASS="VARNAME"
>self</TT
> if you are calling the method from within
    the object). For example:</P
><PRE
CLASS="PROGRAMLISTING"
>print label.text()
  </PRE
><P
>Slots are in no way different from
    ordinary functions in Python, so what holds for public members
    also holds for public slots. Protected member variables are a
    vague kind of private&#8212;if you create the
    <TT
CLASS="CLASSNAME"
>QLabel</TT
> from Python, you can access the
    protected members, like <TT
CLASS="VARNAME"
>drawContents()</TT
>, without
    problems, but if the <TT
CLASS="CLASSNAME"
>QLabel</TT
> has been
    created from a C++ class then you cannot access the protected
    member functions.</P
><P
>Properties are currently not
    supported by PyQt&#8212;everything you can set and get with
    properties is also accessible by <TT
CLASS="FUNCTION"
>get()</TT
> and
    <TT
CLASS="FUNCTION"
>set()</TT
> methods.</P
><P
>If you are reading the detailed
    description of a class, you will often come across snippets of C++
    code. These are easy to translate, too. Just keep in mind that
    both a double semi-colon (::) or an arrow (-&#62;) translate to a
    Python dot (.). And you don't need braces or final semicolons, of
    course. Or <TT
CLASS="FUNCTION"
>new</TT
> statements. For
    instance:</P
><PRE
CLASS="PROGRAMLISTING"
>    QLabel *label = new QLabel;
    label-&#62;setFrameStyle( QFrame::Panel | QFrame::Sunken );
    label-&#62;setText( "first line\nsecond line" );
    label-&#62;setAlignment( AlignBottom | AlignRight );
  </PRE
><P
>Could become in Python:</P
><PRE
CLASS="PROGRAMLISTING"
>    label = new QLabel()
    label.setFrameStyle( QFrame.Panel or QFrame.Sunken )
    label.setText( "first line\nsecond line" )
    label.setAlignment( Qt.AlignBottom or Qt.AlignRight )
  </PRE
><P
>Note also that certain pre-defined
    values, called constants in C++ (and lots of other languages), are
    placed either in a certain <SPAN
><I
CLASS="EMPHASIS"
>class</I
></SPAN
>, not
    <SPAN
><I
CLASS="EMPHASIS"
>object instances</I
></SPAN
> or in the
    <TT
CLASS="CLASSNAME"
>Qt</TT
> pseudoclass. Thus, the
    <TT
CLASS="VARNAME"
>Panel</TT
> or <TT
CLASS="VARNAME"
>Sunken</TT
> constants
    are accessed from the <TT
CLASS="CLASSNAME"
>QFrame</TT
> class, while
    the <TT
CLASS="VARNAME"
>AlignBottom</TT
> and
    <TT
CLASS="VARNAME"
>AlignRight</TT
> constants are taken from the
    <TT
CLASS="CLASSNAME"
>Qt</TT
> pseudoclass. Note also that it isn't
    necessary to prefix <TT
CLASS="CLASSNAME"
>Qt</TT
> in C++, but that
    this is obligatory in Python.</P
><P
>A bit like constants are
    <SPAN
><I
CLASS="EMPHASIS"
>static</I
></SPAN
> methods, and are defined on the
    class:</P
><PRE
CLASS="PROGRAMLISTING"
>QObject.connect()  
  </PRE
><P
><TT
CLASS="CLASSNAME"
>QLabel</TT
>
    doesn't have any signals or static members. For those we had
    better look at another class:
    <TT
CLASS="CLASSNAME"
>QScrollbar</TT
>.</P
><P
>Signals have already been discussed
    in detail in <A href="index.lxp%3Flxpwrap=c1267.htm">Chapter 7</A
>. Here I only want to mention the
    way you must remove any fluff from the declaration. Signals are
    placed in a Python dictionary by <SPAN
CLASS="APPLICATION"
>sip</SPAN
>,
    so you really want to get the string argument to
    <TT
CLASS="FUNCTION"
>SIGNAL()</TT
> right.</P
><P
>So, if there are no arguments to
    the signal, you can just copy it, including the brackets. If there
    are arguments you need to copy the entire argument list, but not
    the variable name. So:</P
><PRE
CLASS="PROGRAMLISTING"
>void valueChanged ( int value ) 
  </PRE
><P
>Can be used as:</P
><PRE
CLASS="PROGRAMLISTING"
>QObject.connect(sbar,SIGNAL("valueChanged(int)"),someFunction)
  </PRE
><P
>On the other hand, if there are
    asterisks involved, then you have to copy those, too. In
    <TT
CLASS="CLASSNAME"
>QListView</TT
>, </P
><PRE
CLASS="PROGRAMLISTING"
>void returnPressed ( QListViewItem * ) 
  </PRE
><P
>Becomes:</P
><PRE
CLASS="PROGRAMLISTING"
>    self.connect(self,
                 SIGNAL("returnPressed(QListViewItem *)"),
                 self.slotItemSelected)
  </PRE
><P
>The Qt documentation is not always
    consistent in giving signal parameters variable names - sometimes
    they do, sometimes they don't.</P
><P
>Finally, wherever there is a NULL
    in C++, you can use None, but you can also use None in many cases
    where there is a zero (0) (this being a pointer to nowhere). That
    means that everywhere a function takes an object (instead of a
    simple integer) as a parameter, you can use None. A zero is often
    given as a default argument in these cases, and then you don't
    need to give any parameter. Thus:</P
><PRE
CLASS="PROGRAMLISTING"
>QListView ( QWidget * parent = 0, const char * name = 0 ) 
  </PRE
><P
>Can be called as:</P
><PRE
CLASS="PROGRAMLISTING"
>listview = QListView(None, None)
  </PRE
><P
>or:</P
><PRE
CLASS="PROGRAMLISTING"
>listview = QListView()
  </PRE
><P
>You can also use actual arguments,
    of course. You almost never need to actually pass something for
    the <TT
CLASS="VARNAME"
>name</TT
> parameter, but it makes for nicer
    debugging:</P
><PRE
CLASS="PROGRAMLISTING"
>listview = QListView(parentWindows, "listview")
  </PRE
><P
>As you've seen, it's not difficult at all to translate from
    C++ to Python &#8212; even if you don't know any C or C++. If you
    do want to know more about C++, I can recommend Steven Oualline's
    book, <I
CLASS="CITETITLE"
>Practical C++ Programming</I
> as a good
    beginners title.</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A accesskey="P" href="index.lxp%3Flxpwrap=p8645.htm">Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="H" href="index.lxp%3Flxpwrap=book1.htm">Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A accesskey="N" href="index.lxp%3Flxpwrap=a8743.htm">Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Appendices</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="U" href="index.lxp%3Flxpwrap=p8645.htm">Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>PyQwt: Python Bindings for Qwt</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
      </td>
      </tr>
      </table>
      </td>
    </tr>
  </table>
  
    
