

  
  <table border="0" cellspacing="0" cellpadding="3" width="100%"><tr><td>
    <div align="center" id="bldcontent">
      <a href="http://www.opendocspublishing.com/"><img src="../images/opendocs.png" width="63" height="76" border="0"></a>
      <br>
      <div class="symbol">Your OpenSource Publisher&#153;</div>
    </div>
    
  </td></tr></table>
  
  <div align="center" class="author">
      	<a href="../products.lxp.html">Products</a>
	&nbsp;|&nbsp;
	<a href="../wheretobuy.lxp.html">Where to buy</a>
	&nbsp;|&nbsp;
	<a href="../bookstore.lxp.html">Retailers</a>
	&nbsp;|&nbsp;
	<a href="../FAQ.lxp.html">FAQ</a>
	&nbsp;|&nbsp;
        <a href="../writeforus.lxp.html">Write for Us.</a>
        &nbsp;|&nbsp;
        <a href="index.lxp%3Flxpwrap=x2976.htm#contact">Contact Us.</a>
  </div>
    <table border="0" cellspacing="3" cellpadding="0" width="100%"><tr><td width="100%">
      <div class="content">
        <table border="0" cellspacing="2" cellpadding="0" width="100%"><tr><td width="100%">
          <div align="center">
<H4 CLASS="AUTHOR"><A NAME="AEN5">Boudewijn Rempt</A>
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
<img src="ODPyQT125.png">
</a>
<br>
ISBN: 0-97003300-4-4
<br>
<a href="http://www.amazon.com/exec/obidos/tg/detail/-/0970033044/q4/103-9966647-8957454?v=glance&s=books">
Available from bookstores everywhere or you can order it here.
</a>
<p>
You can download the source files for the book <a href="pyqtsrc.tgz">(code / eps) here.</a>
<hr>
</div>

          
          <HTML
><HEAD
><TITLE
>Basic widgets</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.72
"><LINK
REL="HOME"
TITLE="GUI Programming with Python: QT Edition"
HREF="book1.htm"><LINK
REL="UP"
TITLE="Qt Class Hierarchy"
HREF="c2591.htm"><LINK
REL="PREVIOUS"
TITLE="Widget foundations: QWidget"
HREF="x2765.htm"><LINK
REL="NEXT"
TITLE="Advanced widgets"
HREF="x3270.htm"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GUI Programming with Python: QT Edition</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A accesskey="P" href="index.lxp%3Flxpwrap=x2765.htm">Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 10. Qt Class Hierarchy</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A accesskey="N" href="index.lxp%3Flxpwrap=x3270.htm">Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
>Basic widgets</A
></H1
><P
>All basic screen components are available in PyQt:
        buttons, frames, edit controls, listboxes and comboboxes. All
        these widgets can be drawn in any number of styles, and you
        can even define your own style. Note that the window
        titlebar and borders are not defined by the widget style, but
        by the system you are running. The borders in these
        screenshots are from the KDE System++ style.
       </P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>Basic widgets in the  CDE style</P
></DIV
></P
></DIV
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>Basic widgets in the motif style</P
></DIV
></P
></DIV
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>Basic widgets in the motif plus style</P
></DIV
></P
></DIV
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>Basic widgets in the platinum style</P
></DIV
></P
></DIV
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>Basic widgets in the SGI style</P
></DIV
></P
></DIV
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>Basic widgets in the Windows style</P
></DIV
></P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>QFrame</A
></H2
><P
>Frames are used to group other widgets
        &#8212; either visibly (for instance by drawing a nice bevel
        around them), or invisibly (by managing the geometry of those
        widgets. PyQt offers all the usual options, from panels to
        ridges to bevels, with horizontal and vertical lines thrown in
        for good measure.
        </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>QPushButton</A
></H2
><P
>        Pushbuttons are the mainstay of gui programming. They can be
        adorned with text or with a picture, but not both (you need a
        <TT
CLASS="CLASSNAME"
>QToolButton</TT
> for that).
        <TT
CLASS="CLASSNAME"
>QPushButton</TT
>s are based on an
        abstraction of all button functionality, namely
        <TT
CLASS="CLASSNAME"
>QButton</TT
>, which is also the parent of
        <TT
CLASS="CLASSNAME"
>QCheckBox</TT
>,
        <TT
CLASS="CLASSNAME"
>QRadioButton</TT
> and
        <TT
CLASS="CLASSNAME"
>QToolButton</TT
>. In honor of QPushButton's
        central importance, I want to present a &#8216;Hello'
        application with four buttons, each in a different style. This
        also shows a frame.
        </P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 10-7. buttons.py - Four pushbuttons saying
          &#8216;hello'.</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#
# buttons.py
#

from qt import *
import sys

class MainWindow(QMainWindow):

    def __init__(self, *args):
        apply(QMainWindow.__init__, (self,) + args)
        self.setCaption("Buttons")
        
        self.grid=QGrid(2, self)
        self.grid.setFrameShape(QFrame.StyledPanel)

        self.bn1=QPushButton("Hello World", self.grid)
        self.bn1.setFlat(1)

        self.bn2=QPushButton("Hello World", self.grid)
        self.bn2.setDefault(1)
        
        self.bn3=QPushButton("Hello World", self.grid)
        self.bn3.setToggleButton(1)
        self.bn3.setDown(1)
        
        self.bn4=QPushButton("Hello", self.grid)
                           
        self.setCentralWidget(self.grid)
        
def main(args):
    app=QApplication(args)
    win=MainWindow()
    win.show()
    app.connect(app, SIGNAL("lastWindowClosed()")
                   , app
                   , SLOT("quit()")
                   )
    app.exec_loop()
  
if __name__=="__main__":
    main(sys.argv)
          </PRE
></DIV
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>buttons.py</P
></DIV
></P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>QLabel</A
></H2
><P
>Labels are ubiquitous in a gui
        application &#8212; and the PyQt <TT
CLASS="CLASSNAME"
>QLabel</TT
>
        offers much more than just plain-text labels for use in dialog
        boxes. PyQt labels can also contain rich text or a
        <TT
CLASS="CLASSNAME"
>QMovie</TT
>, such as an animated GIF or PNG.
        Through the <TT
CLASS="FUNCTION"
>setBuddy</TT
> method, a
        <TT
CLASS="CLASSNAME"
>QLabel</TT
> can be associated with another
        control. If any character in the label text is prefixed by an
        ampersand &#8212; &#38; &#8212; that character will be shown
        underlined, and by pressing alt-character, the user can jump
        to the control associated with the label through the buddy
        property.
      </P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 10-8. label.py - a label associated with an
          edit control</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#
# label.py
#
import sys
from qt import *

class dlgLabel(QDialog):

    def __init__(self,parent = None,name = None,modal = 0,fl = 0):
        QDialog.__init__(self,parent,name,modal,fl)
        self.setCaption("label dialog")
        if name == None:
            self.setName("dlgLabel")

        self.layout=QHBoxLayout(self)
        self.layout.setSpacing(6)
        self.layout.setMargin(11)

        self.label=QLabel("&#38;Enter some text", self)
        self.edit=QLineEdit(self)
        self.label.setBuddy(self.edit)

        self.layout.addWidget(self.label)
        self.layout.addWidget(self.edit)


if __name__ == '__main__':
  app = QApplication(sys.argv)
  QObject.connect(app, SIGNAL('lastWindowClosed()')
                     , app
                     , SLOT('quit()')
                     )
  win = dlgLabel()
  app.setMainWidget(win)
  win.show()
  app.exec_loop()
        </PRE
></DIV
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>label.py</P
></DIV
></P
></DIV
><P
>If you press alt-e after starting the
        <TT
CLASS="FILENAME"
>label.py</TT
> script (which is on the CD-ROM),
        you'll see the cursor appearing in the edit field.</P
><P
>You might wonder why the cursor is not the control
        that accepts user input when you start the script &#8212;
        this is a property of PyQt. On starting an application,
        the main window has the focus, not the controls
        associated with it. If you want to make the user's life
        easier, call <TT
CLASS="FUNCTION"
>setFocus()</TT
> on the main
        widget in the <TT
CLASS="FUNCTION"
>__init__</TT
> of the main
        window:</P
><PRE
CLASS="PROGRAMLISTING"
>#
# label2.py
#
import sys
from qt import *

class dlgLabel(QDialog):

    def __init__(self,parent = None,name = None,modal = 0,fl = 0):
        QDialog.__init__(self,parent,name,modal,fl)
        self.setCaption("label dialog")
        if name == None:
            self.setName("dlgLabel")

        self.layout=QHBoxLayout(self)
        self.layout.setSpacing(6)
        self.layout.setMargin(11)

        self.label=QLabel("&#38;Enter some text", self)
        self.edit=QLineEdit(self)
        self.label.setBuddy(self.edit)

        self.layout.addWidget(self.label)
        self.layout.addWidget(self.edit)

        self.edit.setFocus()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    QObject.connect(app, SIGNAL('lastWindowClosed()'),
                    app, SLOT('quit()'))
    win = dlgLabel()
    app.setMainWidget(win)
    win.show()
    app.exec_loop()
        </PRE
><P
>A label is a QWidget; it is thus quite
        possible to handle key and mouse events in a label. You might,
        for instance, want to make a clickable label that looks like
        an URL.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>QRadioButton</A
></H2
><P
>Radio buttons always remind of my tax
        return forms - check <SPAN
><I
CLASS="EMPHASIS"
>one</I
></SPAN
> and only
        <SPAN
><I
CLASS="EMPHASIS"
>one</I
></SPAN
> out of a certain number of choices.
        Radio buttons should not be used if there are more than five
        choices at most, and you would be well advised to limit
        yourself to no more than three. A constellation of radio
        buttons has the advantage that all options are visible at the
        same time, but it takes a lot of screen space. Do not use
        checkboxes instead of radio buttons for exclusive choices.
        People will get confused.
        </P
><P
>Radio buttons include their labels
        &#8212; and these labels can again be marked with an ampersand
        (&#38;) for easy selection. In order to force the &#8216;one
        and only one' choice, combine the mutually exclusive radio
        buttons in a <TT
CLASS="CLASSNAME"
>QButtonGroup</TT
>, or one of
        the descendants: <TT
CLASS="CLASSNAME"
>QVButtonGroup</TT
> for
        vertical layouts (recommended) or
        <TT
CLASS="CLASSNAME"
>QHButtonGroup</TT
> for horizontal layouts
        (these look rather weird). A radiobutton can be initialized
        with <TT
CLASS="FUNCTION"
>setChecked()</TT
>.</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 10-9. radio.py - a group of mutually exclusive
          options</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#
# label.py
#
import sys
from qt import *

class dlgRadio(QDialog):

    def __init__(self,parent = None,name = None,modal = 0,fl = 0):
        QDialog.__init__(self,parent,name,modal,fl)
        self.setCaption("radiobutton dialog")
        if name == None:
            self.setName("dlgRadio")
        self.layout=QVBoxLayout(self)

        self.buttonGroup=QVButtonGroup("Choose your favourite", self)
        self.radio1=QRadioButton("&#38;Blackadder I", self.buttonGroup)
        self.radio2=QRadioButton("B&#38;lackadder II", self.buttonGroup)
        self.radio3=QRadioButton("Bl&#38;ackadder III", self.buttonGroup)
        self.radio4=QRadioButton("Bla&#38;ckadder Goes Forth", self.buttonGroup)

        self.radio1.setChecked(1)

        self.layout.addWidget(self.buttonGroup)

if __name__ == '__main__':
    app = QApplication(sys.argv)
    QObject.connect(app, SIGNAL('lastWindowClosed()'),
                    app, SLOT('quit()'))
    win = dlgRadio()
    app.setMainWidget(win)
    win.show()
    app.exec_loop()
        </PRE
></DIV
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>radio.py</P
></DIV
></P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>QCheckBox</A
></H2
><P
>Checkboxes are another of those gui
        features that makes one think of bureaucratic forms. Check any
        that apply... Checkboxes are as easy to use as radiobuttons,
        and come with a label attached, like radiobuttons. A variation
        which makes for instant user confusion is the tri-state
        checkbox, in which there's a <SPAN
><I
CLASS="EMPHASIS"
>checked</I
></SPAN
>,
        <SPAN
><I
CLASS="EMPHASIS"
>unchecked</I
></SPAN
> and a <SPAN
><I
CLASS="EMPHASIS"
>doesn't
          apply</I
></SPAN
> state &#8212; the doesn't apply state is
        usually rendered to look just like a completely disabled
        checkbox. However, it is sometimes necessary to introduce this
        behavior. Imagine a dialog box that allows the user to set a
        filter:</P
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>A dialog with a tri-state
              checkbox in the <SPAN
><I
CLASS="EMPHASIS"
>&#8216;doesn't
                apply'</I
></SPAN
> state.</P
></DIV
></P
></DIV
><P
>Now the user has three choices: either
        look for solvent persons, for insolvent persons or for both.
        The Platinum style makes it very clear which state the
        checkbox is in, compared to, for instance, the Windows
        style.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>QListBox</A
></H2
><P
>Listboxes are simple containers where a
        variable number of strings can be added. You can allow the
        user to select no item, one item, a range of items or a
        discontinuous set of items. You can enter texts or pixmaps in
        a listbox, but the listbox, like the listview and the
        combobox, doesn't let you associate arbitrary data with the
        items inside it.</P
><P
>This is something you may often want
        &#8212; you let the user select a certain object by clicking
        on an item in the listbox, and you want that object to be
        available in your application, not the string or picture that
        represents the object, or the index of the item in the
        listbox. You can achieve this by coding a small associative
        listbox:</P
><DIV
CLASS="EXAMPLE"
></A
><P
><B
>Example 10-10. listbox.py - A listbox where data can be
          associated with an entry</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#
# listbox.py
#
# listbox with key-to-index and index-to-key mapping
#
import sys
from qt import *

class AssociativeListBox(QListBox):

    def __init__(self, *args):
        apply(QListBox.__init__,(self,)+args)
        self.text2key = {}
        self.key2text = {}
        self.connect(self, SIGNAL("selected(int)"),
                     self.slotItemSelected)

    def insertItem(self, text, key):
        QListBox.insertItem(self, text)
        self.text2key [self.count() - 1] = key
        self.key2text [key]=self.count() - 1

    def currentKey(self):
        return self.text2key[self.currentItem()]

    def setCurrentItem(self, key):
        if self.key2text.has_key(key):
            QListBox.setCurrentItem(self, self.key2text[key])

    def slotItemSelected(self, index):
        key=self.currentKey()
        self.emit(PYSIGNAL("itemSelected"),
                  (key, self.currentText()) )

    def removeItem(self, index):
        del self.text2key[self.currentItem()]
        del self.key2text[index]
        QListView.removeItem(self, index)

class MainWindow(QMainWindow):

    def __init__(self, *args):
        apply(QMainWindow.__init__, (self,) + args)
        self.listbox=AssociativeListBox(self)
        self.listbox.insertItem("Visible text 1", "key1")
        self.listbox.insertItem("Visible text 2", "key2")
        self.listbox.insertItem("Visible text 3", "key3")
        self.setCentralWidget(self.listbox)

        self.connect(self.listbox,PYSIGNAL( "itemSelected"), self.printSelection)

    def printSelection(self, key, text):
            print "Associated with", key, "is", text

def main(args):
    app=QApplication(args)
    win=MainWindow()
    win.show()
    app.connect(app, SIGNAL("lastWindowClosed()")
                                 , app
                                 , SLOT("quit()")
                                 )
    app.exec_loop()

if __name__=="__main__":
    main(sys.argv)
        </PRE
></DIV
><DIV
CLASS="MEDIAOBJECT"
><P
><DIV
CLASS="CAPTION"
><P
>listbox.py</P
></DIV
></P
></DIV
><P
>Of course, the same trick is needed to get something
        useful out of a <TT
CLASS="CLASSNAME"
>QComboBox</TT
> or a
        <TT
CLASS="CLASSNAME"
>QListView</TT
>.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>QComboBox</A
></H2
><P
>A <TT
CLASS="CLASSNAME"
>QComboBox</TT
> offers almost the same
        functionality as a <TT
CLASS="CLASSNAME"
>QListBox</TT
>, but folds
        out and in, preserving screen space. The contents of a
        combobox can be read-only or editable, and you can check the
        correctness of user input using a
        <TT
CLASS="CLASSNAME"
>QValdidator</TT
> object.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>QLineEdit</A
></H2
><P
>This is a simple one-line edit control, familiar to gui
        users everywhere. It supports copy, cut and paste and redo,
        too. There's a special mode for password boxes.
      </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>QMultiLineEdit</A
></H2
><P
><TT
CLASS="CLASSNAME"
>QMultiLineEdit</TT
> provides a very
        simple multi-line editor. This class does not, in any way,
        support rich text &#8212; all text is in the same font, same
        size and same color. You can enable word-wrap, but that's
        about it. There are no limits on the amount of text it can
        handle (as was the case with the old Windows edit control,
        which had a limit of about 32 kb), but with megabytes of data,
        it will become decidedly slow.</P
><P
>With Qt3 this class has become obsolete.
        You're supposed to use the new, advanced
        <TT
CLASS="CLASSNAME"
>QTextEdit</TT
>, instead. After creating a
        <TT
CLASS="CLASSNAME"
>QTextEdit</TT
> object, you'd set the
        textformat to plain with
        <TT
CLASS="FUNCTION"
>QTextEdit.setFormat(Qt.PlainText)</TT
>; no
        user would notice the difference.
        <TT
CLASS="CLASSNAME"
>QTextEdit</TT
> and
        <TT
CLASS="CLASSNAME"
>QMultiLineEdit</TT
> are quite different to
        the programmer, though, and you can still use
        <TT
CLASS="CLASSNAME"
>QMultiLineEdit</TT
> if you need
        compatibility with older versions of Qt.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>QPopupMenu</A
></H2
><P
>One of the most useful things you can
        offer a user in any document-based application is a context
        menu &#8212; press the mouse-button anywhere in the document
        and a list of useful options pop up. PyQt's
        <TT
CLASS="CLASSNAME"
>QPopupMenu</TT
> can be used both as a
        stand-alone popup menu, and within a menu bar. Menu items can
        have a shortcut key associated with them, an accelerator and a
        small icon. The most useful way of adding items to a menu is
        by defining a <TT
CLASS="CLASSNAME"
>QAction</TT
>. You can nest
        menus, and make &#8216;tear-off' menus, where the user can
        click on a &#8216;tear-off handle' which puts the menu in a
        window of its own.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>QProgressBar</A
></H2
><P
><TT
CLASS="CLASSNAME"
>QProgressBar</TT
> gives
        you a horizontal progressbar &#8212; it's quite simple, even
        though it can be set to use one of several different styles.
        There's also <TT
CLASS="CLASSNAME"
>QProgressDialog</TT
> which can
        be used for lengthy actions that completely block access to
        the application. Since PyQt doesn't really support
        multi-threading, it's probably best to stick with the blocking
        dialog.</P
><P
>If you want to get fancy, you can, with a
        bit of juggling, get an approximation to threading by using a
        <TT
CLASS="CLASSNAME"
>QTimer</TT
>. Then it's best to place the
        progress bar in the statusbar of your application, instead of
        a separate non-modal progress dialog.
        <A href="index.lxp%3Flxpwrap=c7391.htm#CH16PAINTINGEXAMPLE">the Section called <I
>A painting example</I
> in Chapter 21</A
> gives an example of the
        use of a timer.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
>QSlider and other small fry</A
></H2
><P
>There are several other, simple
        user-interface widgets: <TT
CLASS="CLASSNAME"
>QDial</TT
>,
        <TT
CLASS="CLASSNAME"
>QLCDNumber</TT
>,
        <TT
CLASS="CLASSNAME"
>QScrollBar</TT
>,
        <TT
CLASS="CLASSNAME"
>QSizeGrip</TT
>,
        <TT
CLASS="CLASSNAME"
>QSpinBox</TT
> and
        <TT
CLASS="CLASSNAME"
>QToolButton</TT
>. These widgets are seldom
        used, mostly because they are rather overspecialized.</P
><P
><TT
CLASS="CLASSNAME"
>QDial</TT
> is a
        potentio-meter like knob. Twiddling it demands a fair
        proficiency with the mouse, and the keyboard interface isn't
        immediately obvious. See <A href="index.lxp%3Flxpwrap=x1408.htm#CH6-EXAMPLE-QDIAL">Example 7-5</A
>
        for an example of using <TT
CLASS="CLASSNAME"
>QDial</TT
>.</P
><P
><TT
CLASS="CLASSNAME"
>QLCDNumber</TT
> is a
        kind of label which can display numbers in an lcd-like format.
        It's mostly interesting for historical reasons &#8212; the
        first version was written for the Sinclair ZX-Spectrum, a 1.9
        MHz Z80 computer with a rubber keyboard and 48 Kb of
        ram.</P
><P
><TT
CLASS="CLASSNAME"
>QScrollBar</TT
> looks
        to be quite useful, because, on the face of it, any gui
        application is full of scrollbars. But those scrollbars come
        automatically with the edit-controls, listboxes and other
        scrollable widgets, and the <TT
CLASS="CLASSNAME"
>QScrollBar</TT
>
        is seldom used in isolation, and then mostly for the same
        purpose as <TT
CLASS="CLASSNAME"
>QDial</TT
>&#8212; as a range
        control. If you want to use it for scrolling a section on
        screen, use the <TT
CLASS="CLASSNAME"
>QScrollView</TT
> class
        instead. 
        </P
><P
>The <TT
CLASS="CLASSNAME"
>QSizeGrip</TT
> is
        <SPAN
><I
CLASS="EMPHASIS"
>extremely</I
></SPAN
> obscure, being at its peak form
        only in statusbars of resizable windows. And those
        <TT
CLASS="CLASSNAME"
>QStatusBar</TT
>s can take care of their
        sizegrips themselves.</P
><P
><TT
CLASS="CLASSNAME"
>QSpinBox</TT
> is another range control.
        It's often used to let the user select a size for a font
        &#8212; she can either type the size directly, or use the
        little arrows to choose a larger or smaller size. Spinboxes
        are often quite fiddly to use.</P
><P
><TT
CLASS="CLASSNAME"
>QToolButton</TT
> is a special button
        that carries more often a picture than a text &#8212; it's
        mostly used in toolbars, where you can add buttons without
        explicitly creating instances of this class.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A accesskey="P" href="index.lxp%3Flxpwrap=x2765.htm">Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="H" href="index.lxp%3Flxpwrap=book1.htm">Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A accesskey="N" href="index.lxp%3Flxpwrap=x3270.htm">Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Widget foundations: QWidget</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A accesskey="U" href="index.lxp%3Flxpwrap=c2591.htm">Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Advanced widgets</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
      </td>
      </tr>
      </table>
      </td>
    </tr>
  </table>
  
    
